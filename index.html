<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Template Manager</title>
    <style>
		/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		   ğŸ“ 1. DESIGN TOKENS - CSS Custom Properties
		   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

		:root {
			/* â”â”â” Colors - Primary Palette â”â”â” */
			--primary-50: #f5f7ff;
			--primary-100: #ebefff;
			--primary-200: #d6ddff;
			--primary-300: #b8c2ff;
			--primary-400: #9aa8ff;
			--primary-500: #667eea;
			--primary-600: #5a67d8;
			--primary-700: #4c51bf;
			--primary-800: #434190;
			--primary-900: #3a3770;
			
			/* â”â”â” Colors - Gray Scale â”â”â” */
			--gray-50: #f9fafb;
			--gray-100: #f3f4f6;
			--gray-200: #e5e7eb;
			--gray-300: #d1d5db;
			--gray-400: #9ca3af;
			--gray-500: #6b7280;
			--gray-600: #4b5563;
			--gray-700: #374151;
			--gray-800: #1f2937;
			--gray-900: #111827;
			
			/* â”â”â” Colors - Semantic â”â”â” */
			--success-50: #ecfdf5;    /* Very light green (mint) */
			--success-100: #d1fae5;   /* Light green */
			--success-200: #a7f3d0;   /* Soft green */
			--success-300: #6ee7b7;   /* Medium green */
			--success-400: #34d399;   /* Green */
			--success-500: #10b981;   /* Emerald (base) */
			--success-600: #059669;   /* Dark emerald */
			--success-700: #047857;   /* Darker emerald */
			--success-800: #065f46;   /* Very dark green */
			--success-900: #064e3b;   /* Almost black green */
			
			--error-50: #fef2f2;
			--error-500: #ef4444;
			--error-600: #dc2626;
			--error-700: #b91c1c;
			
			--warning-50: #fffbeb;
			--warning-500: #f59e0b;
			--warning-600: #d97706;
			--warning-700: #b45309;
			
			--info-50: #eff6ff;
			--info-500: #3b82f6;
			--info-600: #2563eb;
			--info-700: #1d4ed8;
			
			/* â”â”â” Gradients â”â”â” */
			--gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			--gradient-primary-hover: linear-gradient(135deg, #5a67d8 0%, #6a3f94 100%);
			--gradient-shimmer: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
			
			/* Category color - dynamic per element (fallback) */
			--category-color: var(--primary-500);
			
			/* â”â”â” Spacing - 4px base grid â”â”â” */
			--spacing-0: 0;
			--spacing-1: 0.25rem;   /* 4px */
			--spacing-2: 0.5rem;    /* 8px */
			--spacing-3: 0.75rem;   /* 12px */
			--spacing-4: 1rem;      /* 16px */
			--spacing-5: 1.25rem;   /* 20px */
			--spacing-6: 1.5rem;    /* 24px */
			--spacing-8: 2rem;      /* 32px */
			--spacing-10: 2.5rem;   /* 40px */
			--spacing-12: 3rem;     /* 48px */
			--spacing-16: 4rem;     /* 64px */
			
			/* â”â”â” Typography â”â”â” */
			--font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
			--font-mono: 'SF Mono', 'Monaco', 'Consolas', monospace;
			
			--text-xs: 0.75rem;     /* 12px */
			--text-sm: 0.875rem;    /* 14px */
			--text-base: 1rem;      /* 16px */
			--text-lg: 1.125rem;    /* 18px */
			--text-xl: 1.25rem;     /* 20px */
			--text-2xl: 1.5rem;     /* 24px */
			--text-3xl: 1.875rem;   /* 30px */
			--text-4xl: 2.25rem;    /* 36px */
			
			--font-normal: 400;
			--font-medium: 500;
			--font-semibold: 600;
			--font-bold: 700;
			--font-extrabold: 800;
			
			--leading-none: 1;
			--leading-tight: 1.25;
			--leading-snug: 1.375;
			--leading-normal: 1.5;
			--leading-relaxed: 1.625;
			
			--tracking-tighter: -0.05em;
			--tracking-tight: -0.025em;
			--tracking-normal: 0;
			--tracking-wide: 0.025em;
			--tracking-wider: 0.05em;
			
			/* â”â”â” Border Radius â”â”â” */
			--radius-sm: 0.25rem;   /* 4px */
			--radius-md: 0.375rem;  /* 6px */
			--radius-lg: 0.5rem;    /* 8px */
			--radius-xl: 0.75rem;   /* 12px */
			--radius-2xl: 1rem;     /* 16px */
			--radius-3xl: 1.5rem;   /* 24px */
			--radius-full: 9999px;
			
			/* â”â”â” Shadows â”â”â” */
			--shadow-xs: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
			--shadow-sm: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
			--shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
			--shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
			--shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
			--shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
			--shadow-inner: inset 0 2px 4px 0 rgba(0, 0, 0, 0.05);
			
			--shadow-primary: 0 4px 14px 0 rgba(102, 126, 234, 0.3);
			--shadow-success: 0 4px 14px 0 rgba(16, 185, 129, 0.3);
			--shadow-error: 0 4px 14px 0 rgba(239, 68, 68, 0.3);
			--shadow-warning: 0 4px 14px 0 rgba(245, 158, 11, 0.3);
			
			/* â”â”â” Transitions â”â”â” */
			--transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
			--transition-base: 200ms cubic-bezier(0.4, 0, 0.2, 1);
			--transition-slow: 300ms cubic-bezier(0.4, 0, 0.2, 1);
			
			--ease-in: cubic-bezier(0.4, 0, 1, 1);
			--ease-out: cubic-bezier(0, 0, 0.2, 1);
			--ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);
			
			/* â”â”â” Z-Index Layers â”â”â” */
			--z-base: 0;
			--z-dropdown: 1000;
			--z-sticky: 1020;
			--z-modal: 1050;
			--z-toast: 1060;
			--z-tooltip: 1070;
			--z-dialog: 1080;
		}

		/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		   ğŸ”„ 2. RESET & BASE STYLES
		   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

		*, *::before, *::after {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		html {
			font-size: 16px;
			-webkit-font-smoothing: antialiased;
			-moz-osx-font-smoothing: grayscale;
			text-rendering: optimizeLegibility;
			scroll-behavior: smooth;
		}

		body {
			font-family: var(--font-sans);
			font-size: var(--text-base);
			font-weight: var(--font-normal);
			line-height: var(--leading-normal);
			color: var(--gray-900);
			background: 
				linear-gradient(135deg, 
					rgba(102, 126, 234, 0.08) 0%, 
					rgba(118, 75, 162, 0.12) 100%
				),
				linear-gradient(180deg, 
					var(--primary-200) 0%, 
					var(--primary-100) 20%,
					var(--primary-50) 40%, 
					#ffffff 70%,
					var(--gray-100) 100%
				);
			min-height: 100vh;
			overflow-x: hidden;
		}

		h1, h2, h3, h4, h5, h6 {
			font-weight: var(--font-semibold);
			line-height: var(--leading-tight);
			color: var(--gray-900);
		}

		h1 { font-size: var(--text-3xl); letter-spacing: var(--tracking-tight); }
		h2 { font-size: var(--text-2xl); letter-spacing: var(--tracking-tight); }
		h3 { font-size: var(--text-xl); }
		h4 { font-size: var(--text-lg); }

		button, input, textarea, select {
			font-family: inherit;
			font-size: inherit;
			line-height: inherit;
			color: inherit;
		}

		button {
			cursor: pointer;
			border: none;
			background: none;
		}

		input, textarea, select {
			width: 100%;
		}

		ul, ol {
			list-style: none;
		}

		a {
			color: inherit;
			text-decoration: none;
		}

		:focus {
			outline: none;
		}

		:focus-visible:not(input):not(textarea):not(select) {
			outline: 2px solid var(--primary-500);
			outline-offset: 2px;
			border-radius: var(--radius-md);
		}

		::selection {
			background: var(--primary-200);
			color: var(--primary-900);
		}

		/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		   ğŸ“¦ 3. LAYOUT SYSTEM
		   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

		/* â”â”â” Container â”â”â” */
		.container {
			max-width: 1600px;
			margin: 0 auto;
			padding: var(--spacing-6) var(--spacing-4);
			min-height: 100vh;
			display: flex;
			flex-direction: column;
			gap: var(--spacing-6);
		}

		/* â”â”â” Header â”â”â” */
		.header {
			background: white;
			padding: var(--spacing-6);
			border-radius: var(--radius-2xl);
			box-shadow: var(--shadow-sm);
			display: flex;
			justify-content: space-between;
			align-items: center;
			gap: var(--spacing-5);
			flex-wrap: wrap;
			border: 1px solid var(--gray-100);
			transition: all var(--transition-base);
			position: relative;
		}

		.header:hover {
			box-shadow: var(--shadow-md);
			border-color: var(--gray-200);
		}

		.header h1 {
			background: var(--gradient-primary);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			background-clip: text;
			font-weight: var(--font-extrabold);
			font-size: clamp(var(--text-2xl), 5vw, var(--text-3xl));
			letter-spacing: var(--tracking-tight);
		}

		.header-actions {
			display: flex;
			gap: var(--spacing-3);
			flex-wrap: wrap;
			align-items: center;
		}

		/* â”â”â” Main Content Layout â”â”â” */
		.main-content {
			display: grid;
			grid-template-columns: 280px 1fr;
			gap: var(--spacing-6);
			flex: 1;
			align-items: start;
		}

		/* â”â”â” Sidebar â”â”â” */
		.sidebar {
			background: white;
			padding: var(--spacing-6);
			border-radius: var(--radius-2xl);
			box-shadow: var(--shadow-sm);
			display: flex;
			flex-direction: column;
			gap: var(--spacing-5);
			height: fit-content;
			position: sticky;
			top: var(--spacing-6);
			border: 1px solid var(--gray-100);
			transition: all var(--transition-base);
		}

		.sidebar:hover {
			box-shadow: var(--shadow-md);
			border-color: var(--gray-200);
		}

		.sidebar h3 {
			font-size: var(--text-lg);
			font-weight: var(--font-semibold);
			color: var(--gray-900);
			padding-bottom: var(--spacing-3);
			border-bottom: 2px solid var(--gray-200);
		}

		/* â”â”â” Content Area â”â”â” */
		.content-area {
			display: flex;
			flex-direction: column;
			gap: var(--spacing-6);
		}

		/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		   ğŸ¯ 4. COMPONENTS
		   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

		/* â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
		   ğŸ”˜ BUTTONS
		   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” */

		.btn {
			display: inline-flex;
			align-items: center;
			justify-content: center;
			gap: var(--spacing-2);
			padding: var(--spacing-3) var(--spacing-5);
			font-size: var(--text-sm);
			font-weight: var(--font-medium);
			line-height: 1;
			border-radius: var(--radius-xl);
			transition: all var(--transition-base);
			white-space: nowrap;
			user-select: none;
			border: 1px solid transparent;
			position: relative;
		}

		.btn:active {
			transform: scale(0.98);
		}

		.btn:disabled {
			opacity: 0.5;
			cursor: not-allowed;
			transform: none !important;
		}

		/* Primary Button */
		.btn-primary {
			background: var(--gradient-primary);
			color: white;
			box-shadow: var(--shadow-sm);
		}

		.btn-primary:hover:not(:disabled) {
			transform: translateY(-2px);
			box-shadow: var(--shadow-primary);
		}

		/* Secondary Button */
		.btn-secondary {
			background: white;
			color: var(--gray-700);
			border-color: var(--gray-300);
			box-shadow: var(--shadow-xs);
		}

		.btn-secondary:hover:not(:disabled) {
			background: var(--gray-50);
			border-color: var(--gray-400);
			color: var(--gray-900);
		}

		/* Danger Button */
		.btn-danger {
			background: var(--error-500);
			color: white;
			box-shadow: var(--shadow-sm);
		}

		.btn-danger:hover:not(:disabled) {
			background: var(--error-600);
			transform: translateY(-2px);
			box-shadow: var(--shadow-error);
		}

		/* â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
		   ğŸ” SEARCH
		   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” */

		#searchBar {
			width: 100%;
			padding: var(--spacing-4) var(--spacing-5);
			padding-left: var(--spacing-12);
			padding-right: var(--spacing-12);
			border: 2px solid var(--gray-200);
			border-radius: var(--radius-xl);
			font-size: var(--text-base);
			font-weight: var(--font-normal);
			background: white;
			transition: all var(--transition-base);
			box-shadow: var(--shadow-xs);
			background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 24 24' fill='none' stroke='%236b7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cpath d='m21 21-4.35-4.35'%3E%3C/path%3E%3C/svg%3E");
			background-repeat: no-repeat;
			background-position: var(--spacing-4) center;
			background-size: 20px;
		}

		#searchBar::-webkit-search-cancel-button,
		#searchBar::-webkit-search-decoration {
			-webkit-appearance: none;
			appearance: none;
			display: none;
		}

		#searchBar::-ms-clear {
			display: none;
			width: 0;
			height: 0;
		}

		#searchBar:hover {
			border-color: var(--gray-300);
		}

		#searchBar:focus,
		#searchBar:focus-visible {
			outline: none;
			border-color: var(--primary-500);
			box-shadow: var(--shadow-primary), var(--shadow-sm);
			background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 24 24' fill='none' stroke='%23667eea' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cpath d='m21 21-4.35-4.35'%3E%3C/path%3E%3C/svg%3E");
		}

		#searchBar::placeholder {
			color: var(--gray-400);
		}

		.search-clear {
			position: absolute;
			right: var(--spacing-3);
			top: 50%;
			transform: translateY(-50%);
			
			display: flex;
			align-items: center;
			justify-content: center;
			
			width: 28px;
			height: 28px;
			padding: 0;
			
			background: transparent;
			border: none;
			border-radius: var(--radius-full);
			
			font-size: var(--text-lg);
			color: var(--gray-400);
			
			cursor: pointer;
			transition: all 0.15s ease;
			
			appearance: none;
			-webkit-appearance: none;
		}

		.search-clear:hover {
			background: var(--error-50);
			color: var(--error-600);
		}

		.search-clear:active {
			background: var(--error-100);
			color: var(--error-700);
			transform: translateY(-50%) scale(0.95);
		}

		.search-clear:focus {
			outline: none;
			box-shadow: 0 0 0 3px var(--error-100);
		}

		.search-clear[hidden] {
			display: none;
		}

		.search-container {
			position: relative;
		}

		.search-container input[type="search"] {
			padding-right: var(--spacing-12); 
		}

		input[type="search"]::-webkit-search-cancel-button {
			-webkit-appearance: none;
			appearance: none;
		}

		/* ============================================================================
		   DROPDOWN CONTAINER
		   ============================================================================ */

		.smart-search-dropdown {
			position: absolute;
			top: calc(100% + var(--spacing-2));
			left: 0;
			right: 0;
			width: 100%;
			max-width: 100%;
			
			background: linear-gradient(135deg, 
				var(--gray-50) 0%, 
				white 100%
			);
			
			border: 1px solid var(--gray-200);
			border-radius: var(--radius-2xl);
			
			box-shadow: var(--shadow-xl);
			
			max-height: 600px;
			overflow-y: auto;
			overflow-x: hidden;
			
			z-index: 1000;
			
			/* Animation */
			animation: slideDown var(--transition-base) cubic-bezier(0.4, 0, 0.2, 1);
			
			/* Custom scrollbar */
			scrollbar-width: thin;
			scrollbar-color: var(--gray-300) transparent;
		}

		.smart-search-dropdown::-webkit-scrollbar {
			width: 8px;
		}

		.smart-search-dropdown::-webkit-scrollbar-track {
			background: transparent;
		}

		.smart-search-dropdown::-webkit-scrollbar-thumb {
			background: var(--gray-300);
			border-radius: var(--radius-full);
			border: 2px solid transparent;
			background-clip: padding-box;
		}

		.smart-search-dropdown::-webkit-scrollbar-thumb:hover {
			background: var(--gray-400);
			background-clip: padding-box;
		}

		/* ============================================================================
		   STATS HEADER
		   ============================================================================ */

		.search-stats-header {
			position: sticky;
			top: 0;
			z-index: 10;
			
			padding: var(--spacing-4) var(--spacing-5);
			
			background: linear-gradient(135deg, 
				rgba(102, 126, 234, 0.08) 0%, 
				rgba(118, 75, 162, 0.12) 100%
			);
			backdrop-filter: blur(12px);
			-webkit-backdrop-filter: blur(12px);
			
			border-bottom: 1px solid var(--gray-200);
			border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
		}

		.search-stats-main {
			display: flex;
			align-items: center;
			gap: var(--spacing-3);
			
			font-size: var(--text-sm);
			line-height: var(--leading-normal);
			color: var(--gray-700);
			
			margin-bottom: var(--spacing-3);
		}

		.search-stats-main:last-child {
			margin-bottom: 0;
		}

		.stats-icon {
			display: inline-flex;
			align-items: center;
			justify-content: center;
			
			width: 28px;
			height: 28px;
			
			font-size: 16px;
			
			background: white;
			border-radius: var(--radius-lg);
			box-shadow: var(--shadow-sm);
			
			flex-shrink: 0;
		}

		.stats-text {
			flex: 1;
			
			font-size: var(--text-sm);
			line-height: 1.6;
			color: var(--gray-700);
		}

		.stats-text strong {
			font-weight: var(--font-semibold);
			color: var(--gray-900);
		}

		/* ============================================================================
		   CATEGORY BREAKDOWN
		   ============================================================================ */

		.search-category-breakdown {
			margin-top: var(--spacing-3);
			padding-top: var(--spacing-3);
			border-top: 1px solid var(--gray-200);
		}

		.breakdown-label {
			font-size: var(--text-xs);
			font-weight: var(--font-medium);
			color: var(--gray-600);
			text-transform: uppercase;
			letter-spacing: 0.05em;
			
			margin-bottom: var(--spacing-2);
		}

		.breakdown-items {
			display: flex;
			flex-wrap: wrap;
			gap: var(--spacing-2);
			align-items: center;
		}

		.breakdown-item {
			display: inline-flex;
			align-items: center;
			gap: var(--spacing-1);
			
			padding: var(--spacing-1) var(--spacing-3);
			
			background: white;
			border: 1px solid var(--gray-200);
			border-radius: var(--radius-full);
			
			font-size: var(--text-xs);
			line-height: var(--leading-tight);
			color: var(--gray-700);
			
			transition: all var(--transition-fast) cubic-bezier(0.4, 0, 0.2, 1);
			
			cursor: default;
		}

		.breakdown-item:hover {
			background: var(--gray-50);
			border-color: var(--gray-300);
			transform: translateY(-1px);
			box-shadow: var(--shadow-sm);
		}

		.breakdown-item strong {
			font-weight: var(--font-semibold);
			color: var(--gray-900);
		}

		.breakdown-more {
			font-size: var(--text-xs);
			color: var(--gray-500);
			font-style: italic;
		}

		/* ============================================================================
		   EMPTY STATE
		   ============================================================================ */

		.search-empty-state {
			padding: var(--spacing-8) var(--spacing-6);
			text-align: center;
		}

		.empty-icon {
			font-size: 48px;
			line-height: 1;
			
			margin-bottom: var(--spacing-4);
			
			opacity: 0.5;
			
			animation: fadeIn var(--transition-slow) cubic-bezier(0.4, 0, 0.2, 1);
		}

		.empty-title {
			font-size: var(--text-lg);
			font-weight: var(--font-semibold);
			color: var(--gray-900);
			
			margin: 0 0 var(--spacing-3) 0;
			
			animation: fadeIn var(--transition-slow) cubic-bezier(0.4, 0, 0.2, 1) 0.1s backwards;
		}

		.empty-message {
			font-size: var(--text-sm);
			line-height: var(--leading-relaxed);
			color: var(--gray-600);
			
			max-width: 500px;
			margin: 0 auto;
			
			animation: fadeIn var(--transition-slow) cubic-bezier(0.4, 0, 0.2, 1) 0.2s backwards;
		}

		.empty-message strong {
			font-weight: var(--font-semibold);
			color: var(--gray-900);
		}

		.empty-message em {
			font-style: italic;
			color: var(--gray-500);
		}

		/* ============================================================================
		   SEARCH RESULTS LIST
		   ============================================================================ */

		.search-results {
			padding: var(--spacing-2) 0;
		}

		/* ============================================================================
		   SEARCH RESULT ITEM
		   ============================================================================ */

		.search-result-item {
			position: relative;
			
			padding: var(--spacing-4) var(--spacing-5);
			margin: 0 var(--spacing-2);
			margin-bottom: var(--spacing-2);
			
			background: white;
			border: 1px solid var(--gray-200);
			border-radius: var(--radius-xl);
			
			cursor: pointer;
			
			transition: all var(--transition-fast) cubic-bezier(0.4, 0, 0.2, 1);
			
			/* Subtle gradient overlay */
			background-image: linear-gradient(135deg, 
				rgba(255, 255, 255, 0) 0%, 
				rgba(102, 126, 234, 0.02) 100%
			);
		}

		.search-result-item:last-child {
			margin-bottom: 0;
		}

		/* Hover state */
		.search-result-item:hover {
			background: white;
			background-image: linear-gradient(135deg, 
				rgba(102, 126, 234, 0.05) 0%, 
				rgba(118, 75, 162, 0.08) 100%
			);
			
			border-color: var(--primary-300);
			
			transform: translateY(-2px) translateX(2px);
			box-shadow: var(--shadow-lg);
		}

		/* Active/Click state */
		.search-result-item:active {
			transform: translateY(0) translateX(0);
			box-shadow: var(--shadow-md);
		}

		/* Focus state (keyboard navigation) */
		.search-result-item:focus {
			outline: 2px solid var(--primary-500);
			outline-offset: 2px;
			border-color: var(--primary-400);
		}

		/* Focus visible (keyboard only) */
		.search-result-item:focus-visible {
			outline: 2px solid var(--primary-500);
			outline-offset: 2px;
		}

		/* ============================================================================
		   RESULT HEADER
		   ============================================================================ */

		.result-header {
			display: flex;
			align-items: flex-start;
			justify-content: space-between;
			gap: var(--spacing-3);
			
			margin-bottom: var(--spacing-2);
		}

		.result-title {
			flex: 1;
			
			display: flex;
			align-items: center;
			gap: var(--spacing-2);
			flex-wrap: wrap;
			
			font-size: var(--text-base);
			font-weight: var(--font-semibold);
			line-height: var(--leading-tight);
			color: var(--gray-900);
		}

		/* Highlight Ã®n title */
		.result-title .highlight {
			color: var(--primary-700);
			background: linear-gradient(135deg, 
				var(--primary-50) 0%, 
				var(--primary-100) 100%
			);
			padding: 0 4px;
			border-radius: var(--radius-sm);
		}

		/* ============================================================================
		   RELEVANCE BADGES
		   ============================================================================ */

		.relevance-badge {
			display: inline-flex;
			align-items: center;
			
			padding: 2px var(--spacing-2);
			
			font-size: var(--text-xs);
			font-weight: var(--font-medium);
			line-height: var(--leading-tight);
			
			border-radius: var(--radius-full);
			
			transition: all var(--transition-fast) cubic-bezier(0.4, 0, 0.2, 1);
			
			flex-shrink: 0;
		}

		/* High relevance (200+ points) */
		.relevance-badge.relevance-high {
			background: linear-gradient(135deg, 
				var(--success-50) 0%, 
				var(--success-100) 100%
			);
			color: var(--success-700);
			border: 1px solid var(--success-200);
		}

		.search-result-item:hover .relevance-badge.relevance-high {
			background: linear-gradient(135deg, 
				var(--success-100) 0%, 
				var(--success-200) 100%
			);
			border-color: var(--success-300);
		}

		/* Medium relevance (100-199 points) */
		.relevance-badge.relevance-medium {
			background: linear-gradient(135deg, 
				var(--primary-50) 0%, 
				var(--primary-100) 100%
			);
			color: var(--primary-700);
			border: 1px solid var(--primary-200);
		}

		.search-result-item:hover .relevance-badge.relevance-medium {
			background: linear-gradient(135deg, 
				var(--primary-100) 0%, 
				var(--primary-200) 100%
			);
			border-color: var(--primary-300);
		}

		/* Low relevance (<100 points) */
		.relevance-badge.relevance-low {
			background: linear-gradient(135deg, 
				var(--gray-50) 0%, 
				var(--gray-100) 100%
			);
			color: var(--gray-700);
			border: 1px solid var(--gray-200);
		}

		.search-result-item:hover .relevance-badge.relevance-low {
			background: linear-gradient(135deg, 
				var(--gray-100) 0%, 
				var(--gray-200) 100%
			);
			border-color: var(--gray-300);
		}

		/* ============================================================================
		   MATCH TYPE INDICATOR
		   ============================================================================ */

		.result-match-type {
			font-size: var(--text-xs);
			color: var(--gray-500);
			line-height: var(--leading-tight);
			
			white-space: nowrap;
			
			flex-shrink: 0;
		}

		.search-result-item:hover .result-match-type {
			color: var(--gray-600);
		}

		/* ============================================================================
		   CATEGORY BADGE
		   ============================================================================ */

		.result-category {
			margin-bottom: var(--spacing-2);
		}

		.category-badge {
			display: inline-flex;
			align-items: center;
			gap: var(--spacing-1);
			
			padding: var(--spacing-1) var(--spacing-3);
			
			background: linear-gradient(135deg, 
				var(--gray-50) 0%, 
				white 100%
			);
			border: 1px solid var(--gray-200);
			border-radius: var(--radius-full);
			
			font-size: var(--text-xs);
			font-weight: var(--font-medium);
			color: var(--gray-700);
			
			transition: all var(--transition-fast) cubic-bezier(0.4, 0, 0.2, 1);
		}

		.search-result-item:hover .category-badge {
			background: linear-gradient(135deg, 
				var(--gray-100) 0%, 
				var(--gray-50) 100%
			);
			border-color: var(--gray-300);
		}

		/* ============================================================================
		   RESULT SNIPPET
		   ============================================================================ */

		.result-snippet {
			font-size: var(--text-sm);
			line-height: var(--leading-relaxed);
			color: var(--gray-600);
			
			margin-bottom: var(--spacing-3);
			
			/* Truncate long snippets */
			display: -webkit-box;
			-webkit-line-clamp: 3;
			-webkit-box-orient: vertical;
			overflow: hidden;
		}

		.search-result-item:hover .result-snippet {
			color: var(--gray-700);
		}

		/* Highlight Ã®n snippet */
		.result-snippet .highlight {
			font-weight: var(--font-semibold);
			color: var(--primary-700);
			background: linear-gradient(135deg, 
				var(--primary-50) 0%, 
				var(--primary-100) 100%
			);
			padding: 0 4px;
			border-radius: var(--radius-sm);
		}

		.search-result-item:hover .result-snippet .highlight {
			background: linear-gradient(135deg, 
				var(--primary-100) 0%, 
				var(--primary-200) 100%
			);
		}

		/* ============================================================================
		   RESULT TAGS
		   ============================================================================ */

		.result-tags {
			display: flex;
			flex-wrap: wrap;
			gap: var(--spacing-2);
		}

		.result-tags .tag {
			display: inline-flex;
			align-items: center;
			gap: var(--spacing-1);
			
			padding: var(--spacing-1) var(--spacing-2);
			
			background: linear-gradient(135deg, 
				var(--gray-50) 0%, 
				white 100%
			);
			border: 1px solid var(--gray-200);
			border-radius: var(--radius-md);
			
			font-size: var(--text-xs);
			line-height: var(--leading-tight);
			color: var(--gray-600);
			
			transition: all var(--transition-fast) cubic-bezier(0.4, 0, 0.2, 1);
		}

		.search-result-item:hover .result-tags .tag {
			background: linear-gradient(135deg, 
				var(--gray-100) 0%, 
				var(--gray-50) 100%
			);
			border-color: var(--gray-300);
		}

		/* Highlight Ã®n tags */
		.result-tags .tag .highlight {
			font-weight: var(--font-semibold);
			color: var(--primary-700);
		}

		/* ============================================================================
		   HIGHLIGHT GLOBAL
		   ============================================================================ */

		.highlight {
			font-weight: var(--font-semibold);
			color: var(--primary-700);
			background: linear-gradient(135deg, 
				var(--primary-50) 0%, 
				var(--primary-100) 100%
			);
			padding: 0 2px;
			border-radius: 2px;
		}
		
		/* â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
		   ğŸ“Š STATISTICS PANEL
		   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” */

		.stats-panel {
			background: white;
			padding: var(--spacing-6);
			border-radius: var(--radius-2xl);
			box-shadow: var(--shadow-sm);
			border: 1px solid var(--gray-100);
			transition: all var(--transition-base);
		}

		.stats-panel:hover {
			box-shadow: var(--shadow-md);
			border-color: var(--gray-200);
		}

		#statsGrid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
			gap: var(--spacing-4);
		}

		.stat-card {
			background: linear-gradient(135deg, var(--gray-50) 0%, white 100%);
			padding: var(--spacing-5);
			border-radius: var(--radius-xl);
			text-align: center;
			border: 2px solid var(--gray-100);
			transition: all var(--transition-base);
			position: relative;
			overflow: hidden;
		}

		.stat-card::before {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 3px;
			background: var(--gradient-primary);
			transform: scaleX(0);
			transform-origin: left;
			transition: transform var(--transition-base);
		}

		.stat-card:hover {
			border-color: var(--primary-500);
			transform: translateY(-3px);
			box-shadow: var(--shadow-lg);
		}

		.stat-card:hover::before {
			transform: scaleX(1);
		}

		.stat-number {
			font-size: var(--text-3xl);
			font-weight: var(--font-bold);
			background: var(--gradient-primary);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			background-clip: text;
			line-height: var(--leading-none);
			margin-bottom: var(--spacing-2);
			display: block;
		}

		.stat-label {
			font-size: var(--text-sm);
			color: var(--gray-600);
			font-weight: var(--font-medium);
		}

		/* â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
		   ğŸ·ï¸ CATEGORY LIST
		   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” */

		#categoryList {
			display: flex;
			flex-direction: column;
			gap: var(--spacing-2);
			max-height: 60vh;
			overflow-y: auto;
			padding-right: var(--spacing-2);
		}

		#categoryList::-webkit-scrollbar {
			width: 6px;
		}

		#categoryList::-webkit-scrollbar-track {
			background: var(--gray-100);
			border-radius: var(--radius-full);
		}

		#categoryList::-webkit-scrollbar-thumb {
			background: var(--gray-300);
			border-radius: var(--radius-full);
		}

		#categoryList::-webkit-scrollbar-thumb:hover {
			background: var(--gray-400);
		}

		.category-item {
			width: 100%;
			display: flex;
			align-items: center;
			gap: var(--spacing-3);
			padding: var(--spacing-3) var(--spacing-4);
			border-radius: var(--radius-xl);
			background: transparent;
			color: var(--gray-700);
			font-size: var(--text-sm);
			font-weight: var(--font-medium);
			transition: all var(--transition-base);
			border: 2px solid transparent;
			cursor: pointer;
			position: relative;
		}

		.category-item::before {
			content: '';
			position: absolute;
			left: 0;
			top: 50%;
			transform: translateY(-50%) scaleY(0);
			width: 3px;
			height: 70%;
			background: var(--category-color, var(--gradient-primary));
			border-radius: 0 var(--radius-full) var(--radius-full) 0;
			transition: transform var(--transition-base);
		}

		.category-item:hover {
			background: var(--gray-50);
			color: var(--gray-900);
			padding-left: var(--spacing-5);
		}

		.category-item:hover::before {
			transform: translateY(-50%) scaleY(1);
		}

		.category-item.active {
			background: var(--category-color, var(--gradient-primary));
			color: white;
			border-color: transparent;
			box-shadow: 0 4px 14px 0 rgba(0, 0, 0, 0.15);
			padding-left: var(--spacing-5);
		}

		.category-item.active::before {
			transform: translateY(-50%) scaleY(1);
			background: white;
		}

		.category-emoji {
			font-size: var(--text-lg);
			flex-shrink: 0;
		}

		.category-name {
			flex: 1;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}

		.category-count {
			display: inline-flex;
			align-items: center;
			justify-content: center;
			min-width: 24px;
			height: 24px;
			padding: 0 var(--spacing-2);
			background: var(--gray-200);
			color: var(--gray-700);
			font-size: var(--text-xs);
			font-weight: var(--font-semibold);
			border-radius: var(--radius-full);
			flex-shrink: 0;
		}

		.category-item.active .category-count {
			background: rgba(255, 255, 255, 0.25);
			color: white;
		}

		.category-actions {
			display: none;
			gap: var(--spacing-1);
			flex-shrink: 0;
		}

		.category-item:hover .category-actions {
			display: flex;
		}

		.category-btn {
			display: flex;
			align-items: center;
			justify-content: center;
			width: 28px;
			height: 28px;
			border-radius: var(--radius-lg);
			background: rgba(0, 0, 0, 0.06);
			transition: all var(--transition-fast);
			font-size: var(--text-sm);
		}

		.category-btn:hover {
			background: rgba(0, 0, 0, 0.12);
			transform: scale(1.1);
		}

		.category-item.active .category-btn {
			background: rgba(255, 255, 255, 0.2);
		}

		.category-item.active .category-btn:hover {
			background: rgba(255, 255, 255, 0.35);
		}

		.category-item.drag-over {
			background: var(--primary-50);
			border-color: var(--primary-500);
			border-style: dashed;
		}
		
		.category-item.drop-forbidden {
			background: linear-gradient(to bottom, 
				rgba(239, 68, 68, 0.2) 0%, 
				rgba(220, 38, 38, 0.25) 100%
			);
			border-color: var(--error-500);
			border-style: dashed;
			cursor: not-allowed;
			color: #7f1d1d;
		}

		.category-item.drop-forbidden::before {
			background: var(--error-500);
		}

		.category-item.drop-forbidden .category-count {
			background: rgba(239, 68, 68, 0.25);
			color: #7f1d1d;
		}

		.category-exit {
			animation: slideOutLeft var(--transition-slow) ease-out forwards;
		}

		@keyframes slideOutLeft {
			to {
				opacity: 0;
				transform: translateX(-100%);
			}
		}

		/* â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
		   â• ADD CATEGORY BUTTON
		   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” */

		.add-category {
			width: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: var(--spacing-2);
			padding: var(--spacing-4);
			border: 2px dashed var(--gray-300);
			border-radius: var(--radius-xl);
			color: var(--gray-600);
			font-size: var(--text-sm);
			font-weight: var(--font-medium);
			transition: all var(--transition-base);
			background: transparent;
		}

		.add-category:hover {
			border-color: var(--primary-500);
			color: var(--primary-600);
			background: var(--primary-50);
		}

		/* â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
		   ğŸƒ TEMPLATES GRID
		   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” */

		#templatesGrid {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
			gap: var(--spacing-6);
			min-height: 300px;
		}

		/* â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
		   ğŸ´ TEMPLATE CARD
		   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” */

		.template-card {
			background: white;
			border-radius: var(--radius-2xl);
			padding: var(--spacing-6);
			box-shadow: var(--shadow-sm);
			display: flex;
			flex-direction: column;
			gap: var(--spacing-4);
			transition: all var(--transition-base);
			position: relative;
			border: 1px solid var(--gray-100);
			cursor: grab;
			overflow: hidden;
		}

		.template-card::after {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 4px;
			background: var(--category-color, var(--gradient-primary));
			border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
			transform: scaleX(0);
			transform-origin: left;
			transition: transform var(--transition-base);
		}

		.template-card:hover {
			box-shadow: var(--shadow-xl);
			transform: translateY(-4px);
			border-color: var(--primary-200);
		}

		.template-card:hover::after {
			transform: scaleX(1);
		}

		.template-card.dragging {
			opacity: 0.6;
			transform: scale(0.95) rotate(2deg);
			cursor: grabbing;
			box-shadow: var(--shadow-2xl);
		}

		.template-card.drop-target {
			border: 2px dashed var(--primary-500);
			background: var(--primary-50);
			box-shadow: var(--shadow-primary);
		}

		.template-card.drop-forbidden {
			border: 2px dashed var(--error-500);
			background: linear-gradient(to bottom, 
				rgba(239, 68, 68, 0.05) 0%, 
				rgba(220, 38, 38, 0.08) 100%
			);
			opacity: 0.7;
			cursor: not-allowed;
			box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.15);
		}

		.template-card.drop-forbidden::after {
			transform: scaleX(1);
			background: var(--error-500);
		}

		.template-card.drop-forbidden::before {
			content: 'ğŸš«';
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			font-size: 4rem;
			opacity: 0.3;
			pointer-events: none;
			z-index: 1;
		}

		.template-exit {
			animation: scaleOut var(--transition-slow) ease-out forwards;
		}

		@keyframes scaleOut {
			to {
				opacity: 0;
				transform: scale(0.85) rotate(-5deg);
			}
		}

		.drag-handle {
			position: absolute;
			top: var(--spacing-4);
			right: var(--spacing-4);
			width: 36px;
			height: 36px;
			display: flex;
			align-items: center;
			justify-content: center;
			color: var(--gray-400);
			font-size: var(--text-xl);
			cursor: grab;
			border-radius: var(--radius-lg);
			transition: all var(--transition-fast);
			user-select: none;
			z-index: 10;
		}

		.drag-handle:hover {
			background: var(--gray-100);
			color: var(--gray-600);
			transform: scale(1.1);
		}

		.drag-handle:active {
			cursor: grabbing;
			transform: scale(0.95);
		}

		.template-title {
			font-size: var(--text-lg);
			font-weight: var(--font-semibold);
			color: var(--gray-900);
			line-height: var(--leading-tight);
			margin: 0;
			padding-right: var(--spacing-10);
			display: -webkit-box;
			-webkit-line-clamp: 2;
			-webkit-box-orient: vertical;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.template-category {
			display: inline-flex;
			align-items: center;
			gap: var(--spacing-2);
			padding: 6px 14px;
			background: var(--gradient-primary);
			color: white;
			font-size: 0.75rem;
			font-weight: var(--font-bold);
			border-radius: var(--radius-full);
			width: fit-content;
			box-shadow: 0 1px 3px rgba(102, 126, 234, 0.25);
			letter-spacing: 0.05em;
			text-transform: uppercase;
			line-height: 1;
		}

		.template-content {
			color: var(--gray-600);
			font-size: var(--text-sm);
			line-height: var(--leading-normal);
			max-height: 7.5em;
			padding: 0 var(--spacing-4) var(--spacing-4);
			margin: 0 calc(var(--spacing-4) * -1);
			background: linear-gradient(to bottom, var(--gray-50) 0%, #fafafa 100%);
			border: 1px solid var(--gray-200);
			border-radius: var(--radius-xl);
			transition: all var(--transition-base);
			display: -webkit-box;
			-webkit-line-clamp: 5;
			-webkit-box-orient: vertical;
			overflow: hidden;
			text-overflow: ellipsis;
			overflow-wrap: break-word;
			white-space: pre-line;
			cursor: pointer;
			position: relative;
		}

		.template-content:hover {
			background: white;
			border-color: var(--primary-300);
		}

		.template-tags {
			display: flex;
			flex-wrap: wrap;
			gap: var(--spacing-2);
			min-height: 28px;
		}

		.template-tags .tag {
			display: inline-flex;
			align-items: center;
			gap: 4px;
			padding: 4px 10px;
			background: var(--gray-100);
			color: var(--gray-700);
			font-size: 0.625rem;
			font-weight: var(--font-semibold);
			border-radius: var(--radius-full);
			border: 1px solid var(--gray-200);
			transition: all var(--transition-base);
			cursor: default;
			letter-spacing: 0.02em;
		}

		.template-tags .tag::before {
			content: '#';
			opacity: 0.6;
			font-weight: var(--font-bold);
		}

		.template-tags .tag:hover {
			transform: translateY(-2px) scale(1.05);
			box-shadow: 0 3px 8px rgba(0, 0, 0, 0.12);
		}

		/* Tag Color Variants */
		.template-tags .tag:nth-child(6n + 1) {
			background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
			color: #1e40af;
			border-color: #bfdbfe;
		}

		.template-tags .tag:nth-child(6n + 1):hover {
			background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
			color: white;
			border-color: #1d4ed8;
			box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
		}

		.template-tags .tag:nth-child(6n + 2) {
			background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
			color: #065f46;
			border-color: #a7f3d0;
		}

		.template-tags .tag:nth-child(6n + 2):hover {
			background: linear-gradient(135deg, #10b981 0%, #059669 100%);
			color: white;
			border-color: #047857;
			box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
		}

		.template-tags .tag:nth-child(6n + 3) {
			background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
			color: #92400e;
			border-color: #fde68a;
		}

		.template-tags .tag:nth-child(6n + 3):hover {
			background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
			color: white;
			border-color: #b45309;
			box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
		}

		.template-tags .tag:nth-child(6n + 4) {
			background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
			color: #991b1b;
			border-color: #fecaca;
		}

		.template-tags .tag:nth-child(6n + 4):hover {
			background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
			color: white;
			border-color: #b91c1c;
			box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
		}

		.template-tags .tag:nth-child(6n + 5) {
			background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%);
			color: #6b21a8;
			border-color: #e9d5ff;
		}

		.template-tags .tag:nth-child(6n + 5):hover {
			background: linear-gradient(135deg, #a855f7 0%, #9333ea 100%);
			color: white;
			border-color: #7e22ce;
			box-shadow: 0 4px 12px rgba(168, 85, 247, 0.4);
		}

		.template-tags .tag:nth-child(6n + 6) {
			background: linear-gradient(135deg, #fdf2f8 0%, #fce7f3 100%);
			color: #9f1239;
			border-color: #fbcfe8;
		}

		.template-tags .tag:nth-child(6n + 6):hover {
			background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
			color: white;
			border-color: #be185d;
			box-shadow: 0 4px 12px rgba(236, 72, 153, 0.4);
		}

		.template-actions {
			display: flex;
			gap: var(--spacing-2);
			padding-top: var(--spacing-4);
			border-top: 1px solid var(--gray-100);
			margin-top: auto;
		}

		.template-actions button {
			flex: 1;
			padding: var(--spacing-2) var(--spacing-4);
			font-size: var(--text-xs);
			font-weight: var(--font-medium);
			border-radius: var(--radius-lg);
			background: var(--gray-100);
			color: var(--gray-700);
			transition: all var(--transition-fast);
			border: 1px solid var(--gray-200);
		}

		.template-actions button:hover {
			background: var(--gray-200);
			color: var(--gray-900);
			border-color: var(--gray-300);
			transform: translateY(-1px);
			box-shadow: var(--shadow-xs);
		}

		.template-actions button:active {
			transform: translateY(0) scale(0.98);
		}

		.template-actions button[data-action="edit"]:hover {
			background: var(--primary-500);
			color: white;
			border-color: var(--primary-600);
			box-shadow: var(--shadow-primary);
		}

		.template-actions button[data-action="copy"]:hover {
			background: var(--success-500);
			color: white;
			border-color: var(--success-600);
			box-shadow: var(--shadow-success);
		}

		.template-actions button[data-action="delete"]:hover {
			background: var(--error-500);
			color: white;
			border-color: var(--error-600);
			box-shadow: var(--shadow-error);
		}

		/* â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
		   ğŸ“­ EMPTY STATE
		   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” */

		.empty-state {
			grid-column: 1 / -1;
			text-align: center;
			padding: var(--spacing-16) var(--spacing-8);
			background: white;
			border-radius: var(--radius-2xl);
			border: 2px dashed var(--gray-300);
			transition: all var(--transition-base);
		}

		.empty-state:hover {
			border-color: var(--primary-500);
			background: var(--primary-50);
		}

		.empty-state h3 {
			font-size: var(--text-2xl);
			font-weight: var(--font-semibold);
			color: var(--gray-900);
			margin-bottom: var(--spacing-3);
			line-height: var(--leading-tight);
		}

		.empty-state h3 span[aria-hidden="true"] {
			display: inline-block;
			font-size: 2.5rem;
			margin-right: var(--spacing-2);
			vertical-align: middle;
		}

		.empty-state p {
			color: var(--gray-600);
			font-size: var(--text-base);
			font-weight: var(--font-normal);
			line-height: var(--leading-relaxed);
			max-width: 600px;
			margin: 0 auto;
		}

		.empty-state p strong {
			color: var(--gray-900);
			font-weight: var(--font-semibold);
		}

		.empty-state p em {
			color: var(--gray-500);
			font-style: italic;
			font-size: var(--text-sm);
		}

		.empty-state-actions {
			display: flex;
			gap: var(--spacing-3);
			justify-content: center;
			align-items: center;
			margin-top: var(--spacing-6);
			flex-wrap: wrap;
		}

		.empty-state-actions .btn {
			min-width: 140px;
			white-space: nowrap;
			transition: transform var(--transition-fast), 
						box-shadow var(--transition-fast);
		}

		.empty-state-actions .btn:hover {
			transform: translateY(-2px);
			box-shadow: var(--shadow-md);
		}

		.empty-state-actions .btn:active {
			transform: translateY(0);
		}

		/* â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
		   ğŸ­ MODAL
		   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” */

		.modal {
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, 0.6);
			backdrop-filter: blur(8px);
			display: flex;
			align-items: center;
			justify-content: center;
			padding: var(--spacing-4);
			z-index: var(--z-modal);
			opacity: 0;
			visibility: hidden;
			transition: all var(--transition-base);
		}

		.modal.show {
			opacity: 1;
			visibility: visible;
		}

		.modal-content {
			background: white;
			border-radius: var(--radius-3xl);
			box-shadow: var(--shadow-2xl);
			width: 100%;
			max-width: 600px;
			max-height: 90vh;
			overflow-y: auto;
			transform: scale(0.9) translateY(20px);
			transition: transform var(--transition-base);
			border: 1px solid var(--gray-200);
		}

		.modal.show .modal-content {
			transform: scale(1) translateY(0);
		}

		.modal-header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: var(--spacing-6);
			border-bottom: 1px solid var(--gray-200);
			background: linear-gradient(180deg, var(--gray-50) 0%, white 100%);
			border-radius: var(--radius-3xl) var(--radius-3xl) 0 0;
		}

		.modal-header h2 {
			font-size: var(--text-2xl);
			font-weight: var(--font-semibold);
			color: var(--gray-900);
			background: var(--gradient-primary);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			background-clip: text;
		}

		.modal-close {
			width: 40px;
			height: 40px;
			display: flex;
			align-items: center;
			justify-content: center;
			border-radius: var(--radius-lg);
			color: var(--gray-500);
			font-size: var(--text-2xl);
			transition: all var(--transition-fast);
			background: transparent;
		}

		.modal-close:hover {
			background: var(--gray-100);
			color: var(--gray-900);
			transform: rotate(90deg);
		}

		#templateForm {
			padding: var(--spacing-6);
			display: flex;
			flex-direction: column;
			gap: var(--spacing-5);
		}

		.form-group {
			display: flex;
			flex-direction: column;
			gap: var(--spacing-2);
		}

		.form-group label {
			font-size: var(--text-sm);
			font-weight: var(--font-semibold);
			color: var(--gray-700);
		}

		.form-group input,
		.form-group textarea,
		.form-group select {
			padding: var(--spacing-3) var(--spacing-4);
			border: 2px solid var(--gray-200);
			border-radius: var(--radius-xl);
			font-size: var(--text-base);
			transition: all var(--transition-base);
			background: white;
			color: var(--gray-900);
		}

		.form-group input:hover,
		.form-group textarea:hover,
		.form-group select:hover {
			border-color: var(--gray-300);
		}

		.form-group input:focus,
		.form-group input:focus-visible,
		.form-group textarea:focus,
		.form-group textarea:focus-visible,
		.form-group select:focus,
		.form-group select:focus-visible {
			outline: none;
			border-color: var(--primary-500);
			box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
		}

		.form-group textarea {
			resize: vertical;
			min-height: 120px;
			font-family: inherit;
		}

		.form-hint {
			font-size: var(--text-xs);
			color: var(--gray-500);
			font-style: italic;
		}

		.modal-actions {
			display: flex;
			gap: var(--spacing-3);
			padding-top: var(--spacing-5);
			border-top: 1px solid var(--gray-200);
		}

		.modal-actions button {
			flex: 1;
		}

		/* â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
		   ğŸ’¬ DIALOG SYSTEM
		   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” */

		.dialog-overlay {
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, 0.6);
			backdrop-filter: blur(8px);
			display: flex;
			align-items: center;
			justify-content: center;
			padding: var(--spacing-4);
			z-index: var(--z-dialog);
			opacity: 0;
			visibility: hidden;
			transition: all var(--transition-base);
		}

		.dialog-overlay.dialog-open {
			opacity: 1;
			visibility: visible;
		}
		
		.dialog-overlay.dialog-closing {
			opacity: 0;
			pointer-events: none;
			transition: opacity var(--transition-fast);
		}

		.dialog-box {
			background: white;
			border-radius: var(--radius-3xl);
			box-shadow: var(--shadow-2xl);
			width: 100%;
			max-width: 480px;
			padding: var(--spacing-6);
			transform: scale(0.9) translateY(20px);
			transition: transform var(--transition-base);
			border: 1px solid var(--gray-200);
		}

		.dialog-overlay.dialog-open .dialog-box {
			transform: scale(1) translateY(0);
		}

		.dialog-box h3 {
			font-size: var(--text-xl);
			font-weight: var(--font-semibold);
			color: var(--gray-900);
			margin-bottom: var(--spacing-4);
		}

		.dialog-box.danger h3 { color: var(--error-600); }
		.dialog-box.warning h3 { color: var(--warning-600); }
		.dialog-box.info h3 { color: var(--info-600); }
		.dialog-box.success h3 { color: var(--success-600); }

		.dialog-box.default {
			/* Styling neutru pentru dialog type default */
			/* FoloseÈ™te styling-ul base .dialog-box */
		}

		.dialog-closing .dialog-box {
			transform: scale(0.95) translateY(10px);
			opacity: 0;
			transition: transform var(--transition-fast),
						opacity var(--transition-fast);
		}

		.dialog-message {
			color: var(--gray-600);
			font-size: var(--text-base);
			line-height: var(--leading-relaxed);
			margin-bottom: var(--spacing-6);
		}

		.dialog-input-wrapper {
			margin-bottom: var(--spacing-5);
		}

		.dialog-input {
			width: 100%;
			padding: var(--spacing-3) var(--spacing-4);
			border: 2px solid var(--gray-200);
			border-radius: var(--radius-xl);
			font-size: var(--text-base);
			transition: all var(--transition-base);
		}

		.dialog-input:focus,
		.dialog-input:focus-visible {
			outline: none;
			border-color: var(--primary-500);
			box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
		}

		.dialog-input.dialog-input-error {
			border-color: var(--error-500);
		}

		.dialog-error {
			display: none;
			color: var(--error-600);
			font-size: var(--text-sm);
			margin-top: var(--spacing-2);
		}

		.dialog-actions {
			display: flex;
			gap: var(--spacing-3);
			justify-content: flex-end;
		}

		.dialog-actions button {
			min-width: 100px;
		}

		/* â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
		   ğŸ TOAST NOTIFICATIONS
		   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” */

		.toast-container {
			position: fixed;
			top: var(--spacing-6);
			right: var(--spacing-6);
			z-index: var(--z-toast);
			display: flex;
			flex-direction: column;
			gap: var(--spacing-3);
			max-width: 420px;
			width: 100%;
			pointer-events: none;
		}

		.toast {
			background: white;
			border-radius: var(--radius-2xl);
			box-shadow: var(--shadow-xl);
			padding: var(--spacing-4);
			display: flex;
			flex-direction: column;
			gap: var(--spacing-2);
			pointer-events: auto;
			transform: translateX(calc(100% + var(--spacing-6)));
			opacity: 0;
			transition: all var(--transition-base);
			border: 1px solid var(--gray-200);
			border-left-width: 4px;
		}

		.toast.toast-show {
			transform: translateX(0);
			opacity: 1;
		}

		.toast.toast-exit {
			transform: translateX(calc(100% + var(--spacing-6)));
			opacity: 0;
		}

		.toast-success {
			border-left-color: var(--success-500);
			background: linear-gradient(135deg, var(--success-50) 0%, white 100%);
		}

		.toast-error {
			border-left-color: var(--error-500);
			background: linear-gradient(135deg, var(--error-50) 0%, white 100%);
		}

		.toast-warning {
			border-left-color: var(--warning-500);
			background: linear-gradient(135deg, var(--warning-50) 0%, white 100%);
		}

		.toast-info {
			border-left-color: var(--info-500);
			background: linear-gradient(135deg, var(--info-50) 0%, white 100%);
		}

		.toast-content {
			display: flex;
			align-items: flex-start;
			gap: var(--spacing-3);
		}

		.toast-icon {
			font-size: var(--text-xl);
			flex-shrink: 0;
		}

		.toast-message {
			flex: 1;
			color: var(--gray-900);
			font-size: var(--text-sm);
			line-height: var(--leading-relaxed);
			font-weight: var(--font-medium);
		}

		.toast-close {
			width: 28px;
			height: 28px;
			display: flex;
			align-items: center;
			justify-content: center;
			border-radius: var(--radius-lg);
			color: var(--gray-400);
			font-size: var(--text-lg);
			transition: all var(--transition-fast);
			flex-shrink: 0;
			margin-left: auto;
		}

		.toast-close:hover {
			background: var(--gray-100);
			color: var(--gray-900);
			transform: rotate(90deg);
		}

		.toast-progress {
			height: 4px;
			background: var(--gray-100);
			border-radius: var(--radius-full);
			overflow: hidden;
			margin-top: var(--spacing-2);
		}

		.toast-progress-bar {
			height: 100%;
			width: 100%;
			background: var(--gray-400);
			border-radius: var(--radius-full);
			transition: width linear;
		}

		.toast-shake {
			animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
			transform: translate3d(0, 0, 0);
			backface-visibility: hidden;
			perspective: 1000px;
		}

		.toast-success .toast-progress-bar { background: var(--success-500); }
		.toast-error .toast-progress-bar { background: var(--error-500); }
		.toast-warning .toast-progress-bar { background: var(--warning-500); }
		.toast-info .toast-progress-bar { background: var(--info-500); }
		
		/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		   ğŸ¯ 5. UTILITY CLASSES
		   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

		.visually-hidden {
			position: absolute;
			width: 1px;
			height: 1px;
			padding: 0;
			margin: -1px;
			overflow: hidden;
			clip: rect(0, 0, 0, 0);
			white-space: nowrap;
			border-width: 0;
		}

		/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		   ğŸ¬ 6. ANIMATIONS
		   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

		@keyframes fadeIn {
			from { opacity: 0; }
			to { opacity: 1; }
		}

		@keyframes slideInUp {
			from { transform: translateY(20px); opacity: 0; }
			to { transform: translateY(0); opacity: 1; }
		}

		@keyframes slideDown {
			from { opacity: 0; transform: translateY(-10px); }
			to { opacity: 1; transform: translateY(0); }
		}

		@keyframes flash {
			0%, 100% {
				box-shadow: var(--shadow-sm);
				transform: scale(1);
			}
			50% {
				box-shadow: 0 0 0 6px rgba(102, 126, 234, 0.4), var(--shadow-2xl);
				transform: scale(1.03);
			}
		}

		@keyframes shake {
			0%, 100% {
				transform: translateX(0);
			}
			10%, 30%, 50%, 70%, 90% {
				transform: translateX(-8px);
			}
			20%, 40%, 60%, 80% {
				transform: translateX(8px);
			}
		}
		
		/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		   ğŸ¨ 7. SCROLLBAR STYLING
		   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

		::-webkit-scrollbar {
			width: 12px;
			height: 12px;
		}

		::-webkit-scrollbar-track {
			background: var(--gray-100);
			border-radius: var(--radius-full);
		}

		::-webkit-scrollbar-thumb {
			background: var(--gray-400);
			border-radius: var(--radius-full);
			border: 2px solid var(--gray-100);
			transition: background var(--transition-base);
		}

		::-webkit-scrollbar-thumb:hover {
			background: var(--gray-500);
		}

		* {
			scrollbar-width: thin;
			scrollbar-color: var(--gray-400) var(--gray-100);
		}
    </style>
</head>
<body>
	<div class="container">
		<!-- ==================== HEADER ==================== -->
		<header class="header" role="banner">
			<h1>
				<span aria-hidden="true">ğŸ“‹</span>
				Template Manager
			</h1>
			<div class="header-actions" role="toolbar" aria-label="Main actions">
				<!-- Import -->
				<label 
					for="import-file" 
					class="btn btn-primary"
					title="Import templates from JSON file"
					tabindex="0"
				>
					<span aria-hidden="true">ğŸ“¥</span>
					<span>Import</span>
				</label>
				<input 
					type="file" 
					id="import-file" 
					accept=".json,application/json"
					class="visually-hidden"
					aria-label="Import templates from JSON file"
				>

				<!-- Export -->
				<button 
					type="button" 
					class="btn btn-primary" 
					data-action="export"
					title="Export all templates to JSON file (Ctrl+S)"
				>
					<span aria-hidden="true">ğŸ“¤</span>
					<span>Export</span>
				</button>

				<!-- Add Template -->
				<button 
					type="button" 
					class="btn btn-primary" 
					data-action="add-template"
					title="Create new template (Ctrl+N)"
				>
					<span aria-hidden="true">â•</span>
					<span>Add Template</span>
				</button>
			</div>
		</header>
		
		<!-- ==================== MAIN CONTENT ==================== -->
		<div class="main-content">
			<!-- ==================== SIDEBAR ==================== -->
			<aside class="sidebar" role="complementary" aria-label="Template categories">
				<h3 id="categories-heading">
					<span aria-hidden="true">ğŸ“</span>
					<span>Categories</span>
				</h3>
				<nav aria-labelledby="categories-heading">
					<ul 
						id="categoryList" 
						role="tablist" 
						aria-label="Template categories"
					>
						<!-- Categories will be dynamically inserted here -->
					</ul>
				</nav>
				<button 
					type="button" 
					class="add-category" 
					data-action="add-category"
					title="Create a new category"
				>
					<span aria-hidden="true">â•</span>
					<span>New Category</span>
				</button>
			</aside>
			
			<!-- ==================== CONTENT AREA ==================== -->
			<main class="content-area" role="main" id="main-content">
				<!-- Search -->
				<div class="search-container">
					<label for="searchBar" class="visually-hidden">
						Search templates by name, content, or tags
					</label>
					
					<!-- Search input -->
					<input 
						type="search" 
						id="searchBar" 
						placeholder="Search templates..."
						aria-label="Search templates by name, content, or tags"
						autocomplete="off"
						spellcheck="false"
						inputmode="search"
						enterkeyhint="search"
					>
					
					<!-- Clear button (hidden cÃ¢nd input gol) -->
					<button 
						type="button" 
						class="search-clear" 
						id="searchClear"
						aria-label="Clear search"
						title="Clear search (Esc)"
						hidden
					>
						<span aria-hidden="true">âœ•</span>
					</button>
				</div>

				<!-- Templates Grid -->
				<div 
					id="templatesGrid" 
					role="region" 
					aria-live="polite" 
					aria-atomic="false"
					aria-label="Templates list"
				>
					<!-- Templates will be dynamically inserted here -->
				</div>

				<!-- Statistics Panel -->
				<section class="stats-panel" aria-labelledby="stats-heading">
					<h2 id="stats-heading" class="visually-hidden">
						Template Statistics
					</h2>
					<div 
						id="statsGrid"
						role="group"
						aria-label="Template statistics"
					>
						<!-- Stats will be dynamically inserted here -->
					</div>
				</section>
			</main>
		</div>
	</div>

	<!-- ==================== MODAL ==================== -->
	<div 
		class="modal" 
		id="templateModal" 
		role="dialog" 
		aria-modal="true" 
		aria-labelledby="modalTitle"
		aria-describedby="modalDescription"
	>
		<div class="modal-content">
			<div class="modal-header">
				<h2 id="modalTitle">Add New Template</h2>
				<button 
					type="button" 
					class="modal-close" 
					data-action="cancel"
					aria-label="Close dialog"
					title="Close (Escape key)"
				>
					<span aria-hidden="true">âœ•</span>
				</button>
			</div>

			<p id="modalDescription" class="visually-hidden">
				Fill in the form below to create a new template. All fields marked with asterisk are required.
			</p>
			
			<form id="templateForm" autocomplete="off" novalidate>
				<!-- Template Name -->
				<div class="form-group">
					<label for="templateName">
						Template Name 
						<abbr title="Required" aria-label="Required">*</abbr>
					</label>
					<input 
						type="text" 
						id="templateName" 
						name="templateName"
						placeholder="e.g., Order Confirmation Email"
						required
						minlength="3"
						maxlength="200"
						aria-required="true"
						aria-invalid="false"
						aria-describedby="nameHint"
						autocomplete="off"
						autocorrect="on"
						autocapitalize="sentences"
						spellcheck="true"
						inputmode="text"
					>
					<small id="nameHint" class="form-hint">
						Choose a descriptive name (3-200 characters)
					</small>
				</div>
				
				<!-- Category -->
				<div class="form-group">
					<label for="templateCategory">
						Category 
						<abbr title="Required" aria-label="Required">*</abbr>
					</label>
					<select 
						id="templateCategory" 
						name="templateCategory"
						required 
						aria-required="true"
						aria-invalid="false"
						aria-describedby="categoryHint"
					>
						<option value="" disabled selected hidden>
							Select a category
						</option>
						<!-- Categories will be dynamically inserted here -->
					</select>
					<small id="categoryHint" class="form-hint">
						Choose a category to organize your template
					</small>
				</div>
				
				<!-- Content -->
				<div class="form-group">
					<label for="templateContent">
						Content 
						<abbr title="Required" aria-label="Required">*</abbr>
					</label>
					<textarea 
						id="templateContent"
						name="templateContent"
						placeholder="Enter your template content here...&#10;&#10;You can use multiple lines."
						required
						minlength="10"
						maxlength="5000"
						rows="8"
						wrap="soft"
						aria-required="true"
						aria-invalid="false"
						aria-describedby="contentHint"
						autocomplete="off"
						autocorrect="on"
						autocapitalize="sentences"
						spellcheck="true"
					></textarea>
					<small id="contentHint" class="form-hint">
						Template content (10-5000 characters)
					</small>
				</div>
				
				<!-- Tags -->
				<div class="form-group">
					<label for="templateTags">
						Tags 
						<span style="font-weight: normal; color: #6b7280;">(optional)</span>
					</label>
					<input 
						type="text" 
						id="templateTags"
						name="templateTags"
						placeholder="urgent, customer, email"
						maxlength="200"
						aria-describedby="tagsHint"
						autocomplete="off"
						autocorrect="off"
						autocapitalize="none"
						spellcheck="false"
						inputmode="text"
					>
					<small id="tagsHint" class="form-hint">
						Separate tags with commas. Maximum 3 tags, up to 50 characters each
					</small>
				</div>
				
				<!-- Form Actions -->
				<div class="modal-actions">
					<button 
						type="submit" 
						class="btn btn-primary"
					>
						<span aria-hidden="true">ğŸ’¾</span>
						<span>Save Template</span>
					</button>
					<button 
						type="button" 
						class="btn btn-secondary" 
						data-action="cancel"
					>
						<span aria-hidden="true">âœ•</span>
						<span>Cancel</span>
					</button>
				</div>

				<!-- Keyboard Shortcuts Hint -->
				<small 
					class="form-hint" 
					style="display: block; text-align: center; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e5e7eb; color: #6b7280;"
				>
					<kbd style="background: #f3f4f6; padding: 2px 6px; border: 1px solid #d1d5db; border-radius: 3px; font-family: monospace; font-size: 0.875em;">Ctrl</kbd> 
					+ 
					<kbd style="background: #f3f4f6; padding: 2px 6px; border: 1px solid #d1d5db; border-radius: 3px; font-family: monospace; font-size: 0.875em;">Enter</kbd> 
					to save â€¢ 
					<kbd style="background: #f3f4f6; padding: 2px 6px; border: 1px solid #d1d5db; border-radius: 3px; font-family: monospace; font-size: 0.875em;">Esc</kbd> 
					to cancel
				</small>
			</form>
		</div>
	</div>

    <script>
        'use strict';

        /* ============================================================================
           ğŸ“¦ HELPER UTILITIES
           ============================================================================ */

		const Utils = {
			/**
			 * Escape HTML pentru prevenirea XSS
			 * @param {*} text - Textul de escapuit
			 * @returns {string}
			 */
			escapeHtml(text) {
				if (!text) return '';
				const str = String(text);
				return str.replace(/[&<>"'`]/g, c => ({
					'&': '&amp;',
					'<': '&lt;',
					'>': '&gt;',
					'"': '&quot;',
					"'": '&#x27;',
					'`': '&#x60;'
				}[c]));
			},

			/**
			 * Debounce function pentru search
			 * ReturneazÄƒ funcÈ›ie cu metodÄƒ .cancel() pentru cleanup
			 * @param {Function} func - FuncÈ›ia de executat
			 * @param {number} wait - Timpul de aÈ™teptare Ã®n ms
			 * @returns {Function} Debounced function cu .cancel()
			 */
			debounce(func, wait) {
				let timeout;
				
				const debounced = function executedFunction(...args) {
					const context = this;
					clearTimeout(timeout);
					timeout = setTimeout(() => func.apply(context, args), wait);
				};
				
				/**
				 * Cancel pending execution
				 */
				debounced.cancel = function() {
					clearTimeout(timeout);
				};
				
				return debounced;
			},

			/**
			 * GenereazÄƒ ID unic
			 * @param {string} prefix - Prefix opÈ›ional pentru ID
			 * @returns {string}
			 */
			generateId(prefix = '') {
				// VerificÄƒ dacÄƒ crypto.randomUUID este disponibil ca funcÈ›ie
				if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
					try {
						return `${prefix}${crypto.randomUUID()}`;
					} catch (e) {
						// Fallback dacÄƒ randomUUID throws (de ex. context non-secure)
					}
				}
				return `${prefix}${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
			},

			/**
			 * ValideazÄƒ hex color
			 * @param {*} color - Culoarea de validat
			 * @returns {boolean}
			 */
			isValidColor(color) {
				if (typeof color !== 'string') return false;
				const hexRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
				return hexRegex.test(color);
			},

			/**
			 * SanitizeazÄƒ string la lungime maximÄƒ
			 * @param {*} str - String-ul de sanitizat
			 * @param {number} maxLength - Lungimea maximÄƒ
			 * @returns {string}
			 */
			sanitizeString(str, maxLength = 200) {
				if (str == null || str === '') return '';
				
				// Validare maxLength
				const max = typeof maxLength === 'number' && maxLength > 0 ? maxLength : 200;
				
				return String(str).trim().substring(0, max);
			},

			/**
			 * FormateazÄƒ data pentru display
			 * @param {string|Date} isoString - Data de formatat
			 * @returns {string}
			 */
			formatDate(isoString) {
				try {
					if (!isoString) return 'N/A';
					
					const date = new Date(isoString);
					
					if (isNaN(date.getTime())) {
						return 'N/A';
					}
					
					return date.toLocaleDateString(undefined, {
						year: 'numeric',
						month: 'short',
						day: 'numeric'
					});
				} catch (error) {
					return 'N/A';
				}
			}
		};

        /* ============================================================================
           ğŸ’¾ STORAGE MANAGER - localStorage cu validare
           ============================================================================ */
        
        const StorageManager = {
            KEYS: {
                TEMPLATES: 'templates',
                CATEGORIES: 'categories'
            },

            MAX_SIZE: 4.5 * 1024 * 1024, // 4.5MB warning threshold

            /**
             * Load data din localStorage cu validare
             */
            load(key, defaultValue = null, validator = null) {
                try {
                    const data = localStorage.getItem(key);
                    if (!data) return defaultValue;

                    const parsed = JSON.parse(data);
                    
                    // AplicÄƒ validator dacÄƒ existÄƒ
                    if (validator && typeof validator === 'function') {
                        return validator(parsed);
                    }
                    
                    return parsed;
                } catch (error) {
                    console.error(`Error loading ${key} from storage:`, error);
                    return defaultValue;
                }
            },

            /**
             * Save data Ã®n localStorage cu error handling
             */
            save(key, data) {
                try {
                    const jsonString = JSON.stringify(data);
                    
                    // Check size
                    if (jsonString.length > this.MAX_SIZE) {
                        throw new Error('Data exceeds storage limit');
                    }
                    
                    localStorage.setItem(key, jsonString);
                    return { success: true };
                } catch (error) {
                    console.error(`Error saving ${key} to storage:`, error);
                    
                    if (error.name === 'QuotaExceededError') {
                        return { 
                            success: false, 
                            error: 'QUOTA_EXCEEDED',
                            message: 'Storage space exceeded. Please delete old templates or export data.'
                        };
                    }
                    
                    return { 
                        success: false, 
                        error: 'SAVE_ERROR',
                        message: error.message 
                    };
                }
            },

            /**
             * Clear storage
             */
            clear() {
                try {
                    Object.values(this.KEYS).forEach(key => {
                        localStorage.removeItem(key);
                    });
                    return true;
                } catch (error) {
                    console.error('Error clearing storage:', error);
                    return false;
                }
            },

            /**
             * Get storage size
             */
            getSize() {
                try {
                    let total = 0;
                    Object.values(this.KEYS).forEach(key => {
                        const data = localStorage.getItem(key);
                        if (data) total += data.length;
                    });
                    return total;
                } catch {
                    return 0;
                }
            }
        };

        /* ============================================================================
           âœ… VALIDATORS - Validare È™i sanitizare date
           ============================================================================ */

		const Validators = {
			/**
			 * ValideazÄƒ È™i curÄƒÈ›Äƒ un array de templates
			 * @param {Array} templates - Array-ul de templates de validat
			 * @returns {Array} Array cu templates validate È™i curÄƒÈ›ate
			 */
			validateTemplates(templates) {
				const MIN_NAME_LENGTH = 3;
				const MAX_NAME_LENGTH = 200;
				const MIN_CONTENT_LENGTH = 10;
				const MAX_CONTENT_LENGTH = 5000;
				const MAX_TAG_LENGTH = 50;
				const MAX_TAGS = 3;
				
				if (!Array.isArray(templates)) {
					console.warn('Templates must be an array');
					return [];
				}

				let invalidCount = 0;

				const validated = templates
					.filter(t => {
						if (!t || typeof t !== 'object') {
							invalidCount++;
							return false;
						}
						
						const hasValidId = t.id && String(t.id).trim().length > 0;
						
						const nameStr = t.name && typeof t.name !== 'object' ? String(t.name).trim() : '';
						const hasValidName = (
							nameStr.length >= MIN_NAME_LENGTH && 
							nameStr.length <= MAX_NAME_LENGTH
						);
						
						const hasValidCategory = t.category && String(t.category).trim().length > 0;
						
						const contentStr = t.content && typeof t.content !== 'object' ? String(t.content).trim() : '';
						const hasValidContent = (
							contentStr.length >= MIN_CONTENT_LENGTH && 
							contentStr.length <= MAX_CONTENT_LENGTH
						);
						
						if (!hasValidId || !hasValidName || !hasValidCategory || !hasValidContent) {
							invalidCount++;
							return false;
						}
						
						return true;
					})
					.map(t => {
						let tags = [];
						if (Array.isArray(t.tags)) {
							const seenLower = new Set();
							
							for (const tag of t.tags) {
								if (typeof tag !== 'string') continue;
								
								const trimmed = tag.trim();
								if (!trimmed || trimmed.length > MAX_TAG_LENGTH) continue;
								
								const sanitized = Utils.sanitizeString(trimmed, MAX_TAG_LENGTH);
								const sanitizedLower = sanitized.toLowerCase();
								
								if (!sanitized || seenLower.has(sanitizedLower)) continue;
								
								seenLower.add(sanitizedLower);
								tags.push(sanitized);
								
								if (tags.length >= MAX_TAGS) break;
							}
						}
						
						let createdAt = new Date().toISOString();
						if (t.createdAt) {
							const date = new Date(t.createdAt);
							if (!isNaN(date.getTime())) {
								createdAt = date.toISOString();
							}
						}
						
						const order = typeof t.order === 'number' && !isNaN(t.order) && t.order >= 0
							? t.order 
							: 0;
						
						return {
							id: String(t.id).trim(),
							name: Utils.sanitizeString(t.name, MAX_NAME_LENGTH),
							category: String(t.category).trim(),
							content: Utils.sanitizeString(t.content, MAX_CONTENT_LENGTH),
							tags: tags,
							createdAt: createdAt,
							active: Boolean(t.active ?? true),
							order: order
						};
					});

				if (invalidCount > 0) {
					console.warn(`Filtered ${invalidCount} invalid templates`);
				}

				return validated;
			},

			/**
			 * ValideazÄƒ È™i curÄƒÈ›Äƒ un array de categorii
			 * @param {Array} categories - Array-ul de categorii de validat
			 * @returns {Array} Array cu categorii validate È™i curÄƒÈ›ate
			 */
			validateCategories(categories) {
				if (!Array.isArray(categories)) {
					console.warn('Categories must be an array');
					return [];
				}

				const seenIds = new Set();
				let invalidCount = 0;

				const validated = categories
					.filter(c => {
						if (!c || typeof c !== 'object') {
							invalidCount++;
							return false;
						}
						
						const hasValidId = c.id && String(c.id).trim().length > 0;
						const hasValidName = c.name && String(c.name).trim().length > 0;
						
						if (!hasValidId || !hasValidName) {
							invalidCount++;
							return false;
						}
						
						const categoryId = String(c.id).trim();
						if (seenIds.has(categoryId)) {
							invalidCount++;
							return false;
						}
						
						seenIds.add(categoryId);
						return true;
					})
					.map(c => {
						const sanitizedName = Utils.sanitizeString(c.name, 100);
						
						let sanitizedEmoji = c.emoji ? String(c.emoji).trim() : '';
						if (sanitizedEmoji.length > 20) {
							sanitizedEmoji = '';
						}
						
						return {
							id: String(c.id).trim(),
							name: sanitizedName || 'Unnamed',
							emoji: sanitizedEmoji || 'ğŸ“',
							color: Utils.isValidColor(c.color) ? c.color : '#667eea'
						};
					});

				if (invalidCount > 0) {
					console.warn(`Filtered ${invalidCount} invalid categories`);
				}

				return validated;
			},

			/**
			 * ValideazÄƒ datele unui template din formular
			 * @param {Object} data - Datele template-ului de validat
			 * @param {Array} existingTemplates - Templates existente pentru verificare duplicate
			 * @param {string|null} excludeId - ID-ul template-ului de exclus din verificare (la editare)
			 * @returns {Object} { valid: boolean, errors: string[] }
			 */
			validateTemplateInput(data, existingTemplates = [], existingCategories = [], excludeId = null) {
				try {
					const errors = [];

					if (!data || typeof data !== 'object') {
						errors.push('Invalid template data');
						return { valid: false, errors };
					}

					const trimmedName = data.name ? data.name.trim() : '';
					const trimmedContent = data.content ? data.content.trim() : '';

					if (!trimmedName || trimmedName.length < 3) {
						errors.push('Template name must be at least 3 characters');
					}

					if (trimmedName.length > 200) {
						errors.push('Template name is too long (max 200 characters)');
					}

					if (!data.category) {
						errors.push('Please select a category');
					}

					if (data.category) {
						if (!Array.isArray(existingCategories) || existingCategories.length === 0) {
							errors.push('No categories available. Please create a category first.');
						} else {
							const categoryExists = existingCategories.some(c => c.id === data.category);
							if (!categoryExists) {
								errors.push('Selected category no longer exists');
							}
						}
					}

					if (!trimmedContent || trimmedContent.length < 10) {
						errors.push('Template content must be at least 10 characters');
					}

					if (trimmedContent.length > 5000) {
						errors.push('Template content is too long (max 5000 characters)');
					}

					if (data.tags && data.tags.length > 0) {
						if (!Array.isArray(data.tags)) {
							errors.push('Tags must be an array');
						} else if (data.tags.length > 3) {
							errors.push('Maximum 3 tags allowed');
						} else {
							const invalidTags = data.tags.filter(tag => {
								if (typeof tag !== 'string') return true;
								const trimmed = tag.trim();
								return trimmed.length === 0 || trimmed.length > 50;
							});
							
							if (invalidTags.length > 0) {
								errors.push('All tags must be between 1 and 50 characters');
							}
						}
					}

					if (trimmedName) {
						const nameLower = trimmedName.toLowerCase();
						const duplicate = existingTemplates.find(t => 
							t.name.toLowerCase() === nameLower && 
							t.id !== excludeId
						);
						
						if (duplicate) {
							errors.push('A template with this name already exists');
						}
					}

					return {
						valid: errors.length === 0,
						errors
					};
					
				} catch (error) {
					console.error('Error validating template input:', error);
					return {
						valid: false,
						errors: ['Validation error occurred']
					};
				}
			}
		};

        /* ============================================================================
           ğŸ­ DIALOG MANAGER
           ============================================================================ */
        
		const DialogManager = {
			activeDialog: null,
			dialogIdCounter: 0,
			
			confirm({ title, message, confirmText = 'Confirm', cancelText = 'Cancel', type = 'default' }) {
				const validTypes = ['default', 'danger', 'warning', 'info'];
				const safeType = validTypes.includes(type) ? type : 'default';
				
				const formattedMessage = this.formatMessage(message);
				
				return this._showDialog({
					title,
					content: `<div class="dialog-message">${formattedMessage}</div>`,
					confirmText,
					cancelText,
					type: safeType,
					role: 'alertdialog',
					onConfirm: () => true,
					onCancel: () => false
				});
			},

			prompt({ 
				title, 
				message, 
				placeholder = '', 
				defaultValue = '', 
				confirmText = 'OK', 
				cancelText = 'Cancel',
				maxlength = 200,
				validator = null,
				allowEmpty = false,
				validateOnChange = false
			}) {
				const inputId = `dialog-input-${++this.dialogIdCounter}`;
				const errorId = `dialog-error-${this.dialogIdCounter}`;
				
				const formattedMessage = message ? this.formatMessage(message) : '';
				
				const content = `
					${formattedMessage ? `<div class="dialog-message">${formattedMessage}</div>` : ''}
					<div class="dialog-input-wrapper">
						<input 
							type="text" 
							id="${inputId}"
							class="dialog-input" 
							placeholder="${Utils.escapeHtml(placeholder)}"
							value="${Utils.escapeHtml(defaultValue)}"
							maxlength="${maxlength}"
							autocomplete="off"
							aria-describedby="${errorId}"
						>
						<div id="${errorId}" class="dialog-error" role="alert" aria-live="polite"></div>
					</div>
				`;
				
				return this._showDialog({
					title,
					content,
					confirmText,
					cancelText,
					type: 'default',
					role: 'dialog',
					onConfirm: (overlay) => {
						const input = overlay.querySelector(`#${inputId}`);
						const value = input.value.trim();
						
						if (!allowEmpty && !value) {
							this.showValidationError(overlay, errorId, 'This field cannot be empty');
							input.focus();
							return null;
						}
						
						if (validator && typeof validator === 'function') {
							const validationResult = validator(value);
							
							if (validationResult !== true) {
								const errorMessage = typeof validationResult === 'string' 
									? validationResult 
									: 'Invalid input';
								
								this.showValidationError(overlay, errorId, errorMessage);
								input.focus();
								return null;
							}
						}
						
						return value || (allowEmpty ? '' : null);
					},
					onCancel: () => null,
					focusSelector: `#${inputId}`,
					onMount: (overlay) => {
						const input = overlay.querySelector(`#${inputId}`);
						if (input) {
							input.focus();
							input.select();
							
							if (validateOnChange && validator) {
								input.addEventListener('input', () => {
									const value = input.value.trim();
									const validationResult = validator(value);
									
									if (validationResult === true) {
										this.clearValidationError(overlay, errorId);
									} else {
										const errorMessage = typeof validationResult === 'string' 
											? validationResult 
											: 'Invalid input';
										this.showValidationError(overlay, errorId, errorMessage);
									}
								});
							}
						}
					}
				});
			},
			
			formatMessage(message) {
				if (!message) return '';
				
				const escaped = Utils.escapeHtml(message);
				return escaped.replace(/\n/g, '<br>');
			},
			
			showValidationError(overlay, errorId, message) {
				const errorElement = overlay.querySelector(`#${errorId}`);
				if (errorElement) {
					errorElement.textContent = message;
					errorElement.style.display = 'block';
				}
				
				const input = errorElement?.previousElementSibling;
				if (input) {
					input.classList.add('dialog-input-error');
					input.setAttribute('aria-invalid', 'true');
				}
			},
			
			clearValidationError(overlay, errorId) {
				const errorElement = overlay.querySelector(`#${errorId}`);
				if (errorElement) {
					errorElement.textContent = '';
					errorElement.style.display = 'none';
				}
				
				const input = errorElement?.previousElementSibling;
				if (input) {
					input.classList.remove('dialog-input-error');
					input.setAttribute('aria-invalid', 'false');
				}
			},
			
			_showDialog({ 
				title, 
				content, 
				confirmText, 
				cancelText, 
				type, 
				role,
				onConfirm, 
				onCancel,
				focusSelector = '[data-action="confirm"]',
				onMount = null
			}) {
				if (this.activeDialog) {
					console.warn('Dialog already open, cannot open another');
					return Promise.reject(new Error('DIALOG_ALREADY_OPEN'));
				}
				
				return new Promise((resolve, reject) => {
					try {
						const overlay = document.createElement('div');
						overlay.className = 'dialog-overlay';
						overlay.innerHTML = `
							<div class="dialog-box ${type}" role="${role}" aria-labelledby="dialog-title" aria-modal="true">
								<h3 id="dialog-title">${Utils.escapeHtml(title)}</h3>
								${content}
								<div class="dialog-actions">
									<button type="button" class="btn btn-secondary" data-action="cancel">
										${Utils.escapeHtml(cancelText)}
									</button>
									<button type="button" class="btn btn-primary ${type === 'danger' ? 'btn-danger' : ''}" data-action="confirm">
										${Utils.escapeHtml(confirmText)}
									</button>
								</div>
							</div>
						`;

						document.body.appendChild(overlay);
						this.activeDialog = overlay;
						
						const dialogBox = overlay.querySelector('.dialog-box');
						const focusableElements = dialogBox.querySelectorAll(
							'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
						);
						
						if (focusableElements.length === 0) {
							throw new Error('Dialog has no focusable elements');
						}
						
						const firstFocusable = focusableElements[0];
						const lastFocusable = focusableElements[focusableElements.length - 1];

						let resolved = false;

						const handleConfirm = () => {
							if (resolved) return;
							
							try {
								const result = onConfirm(overlay);
								
								if (result !== null) {
									resolved = true;
									resolve(result);
									cleanup();
								}
							} catch (error) {
								console.error('Error in onConfirm:', error);
								resolved = true;
								reject(error);
								cleanup();
							}
						};

						const handleCancel = () => {
							if (resolved) return;
							
							try {
								resolved = true;
								resolve(onCancel());
								cleanup();
							} catch (error) {
								console.error('Error in onCancel:', error);
								resolved = true;
								reject(error);
								cleanup();
							}
						};

						const handleClick = (e) => {
							const action = e.target.dataset.action;
							if (action === 'confirm') {
								handleConfirm();
							} else if (action === 'cancel') {
								handleCancel();
							}
						};
						
						let clickStartedOnOverlay = false;
						
						const handleMouseDown = (e) => {
							clickStartedOnOverlay = (e.target === overlay);
						};
						
						const handleMouseUp = (e) => {
							try {
								if (e.target === overlay && clickStartedOnOverlay) {
									handleCancel();
								}
							} finally {
								clickStartedOnOverlay = false;
							}
						};

						const handleKeydown = (e) => {
							if (e.key === 'Escape') {
								e.preventDefault();
								handleCancel();
								return;
							}
							
							if (e.key === 'Tab') {
								if (e.shiftKey) {
									if (document.activeElement === firstFocusable) {
										e.preventDefault();
										lastFocusable.focus();
									}
								} else {
									if (document.activeElement === lastFocusable) {
										e.preventDefault();
										firstFocusable.focus();
									}
								}
								return;
							}
							
							if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
								e.preventDefault();
								
								const activeButton = e.target.closest('button[data-action]');
								if (activeButton) {
									const action = activeButton.dataset.action;
									if (action === 'cancel') {
										handleCancel();
									} else if (action === 'confirm') {
										handleConfirm();
									}
								} else {
									handleConfirm();
								}
							}
						};

						const cleanup = () => {
							overlay.removeEventListener('mousedown', handleMouseDown);
							overlay.removeEventListener('mouseup', handleMouseUp);
							overlay.removeEventListener('click', handleClick);
							document.removeEventListener('keydown', handleKeydown);
							
							overlay.classList.add('dialog-closing');
							
							setTimeout(() => {
								if (this.activeDialog === overlay) {
									this.activeDialog = null;
								}
								
								if (overlay.parentNode) {
									overlay.remove();
								}
							}, 200);
						};

						overlay.addEventListener('mousedown', handleMouseDown);
						overlay.addEventListener('mouseup', handleMouseUp);
						overlay.addEventListener('click', handleClick);
						document.addEventListener('keydown', handleKeydown);

						requestAnimationFrame(() => {
							overlay.classList.add('dialog-open');
							
							if (onMount) {
								onMount(overlay);
							} else {
								const focusTarget = overlay.querySelector(focusSelector);
								if (focusTarget) {
									focusTarget.focus();
								} else {
									firstFocusable.focus();
								}
							}
						});
						
					} catch (error) {
						console.error('Error creating dialog:', error);
						
						if (this.activeDialog === overlay) {
							this.activeDialog = null;
						}
						
						reject(error);
					}
				});
			}
		};

        /* ============================================================================
           ğŸ TOAST MANAGER - NotificÄƒri user-friendly
           ============================================================================ */
        
		const ToastManager = {
			toasts: [],
			maxToasts: 3,
			container: null,
			toastIdCounter: 0,
			
			init() {
				if (!this.container) {
					this.container = document.createElement('div');
					this.container.className = 'toast-container';
					this.container.setAttribute('aria-live', 'polite');
					this.container.setAttribute('aria-atomic', 'false');
					document.body.appendChild(this.container);
				}
			},
			
			show(message, type = 'success', duration = 3000, options = {}) {
				this.init();
				
				const {
					closable = true,
					pauseOnHover = true,
					showProgress = true,
					allowDuplicates = false,
					icon = null,
					onClick = null
				} = options;
				
				const validTypes = ['success', 'error', 'warning', 'info'];
				const safeType = validTypes.includes(type) ? type : 'info';
				
				if (!allowDuplicates) {
					const duplicate = this.toasts.find(t => 
						t.message === message && 
						t.type === safeType &&
						!t.isClosing
					);
					
					if (duplicate) {
						this.shake(duplicate.element);
						return duplicate.id;
					}
				}
				
				while (this.toasts.filter(t => !t.isClosing).length >= this.maxToasts) {
					const oldest = this.toasts.find(t => !t.isClosing);
					if (oldest) {
						this.hideImmediate(oldest.id);
					} else {
						break;
					}
				}
				
				const toastId = ++this.toastIdCounter;
				const toast = this.createToast(toastId, message, safeType, duration, {
					closable,
					pauseOnHover,
					showProgress,
					icon,
					onClick
				});
				
				this.toasts.push(toast);
				this.container.appendChild(toast.element);
				
				requestAnimationFrame(() => {
					toast.element.classList.add('toast-show');
					
					if (duration > 0) {
						toast.startTimer();
					}
				});
				
				return toastId;
			},
			
			createToast(id, message, type, duration, options) {
				const element = document.createElement('div');
				element.className = `toast toast-${type}`;
				element.setAttribute('role', 'alert');
				element.dataset.toastId = id;
				
				const icons = {
					success: 'âœ…',
					error: 'âŒ',
					warning: 'âš ï¸',
					info: 'â„¹ï¸'
				};
				
				const displayIcon = options.icon || icons[type];
				
				element.innerHTML = `
					<div class="toast-content">
						<span class="toast-icon" aria-hidden="true">${displayIcon}</span>
						<span class="toast-message">${Utils.escapeHtml(message).replace(/\n/g, '<br>')}</span>
						${options.closable ? '<button class="toast-close" aria-label="Close notification">âœ•</button>' : ''}
					</div>
					${options.showProgress && duration > 0 ? '<div class="toast-progress"><div class="toast-progress-bar"></div></div>' : ''}
				`;
				
				const toast = {
					id,
					element,
					message,
					type,
					duration,
					isClosing: false,
					isPaused: false,
					startTime: null,
					remainingTime: duration,
					timerId: null,
					listeners: []
				};
				
				const addListener = (target, event, handler) => {
					target.addEventListener(event, handler);
					toast.listeners.push({ target, event, handler });
				};
				
				if (options.closable) {
					const closeBtn = element.querySelector('.toast-close');
					addListener(closeBtn, 'click', (e) => {
						e.stopPropagation();
						this.hide(id);
					});
				}
				
				if (options.onClick) {
					element.style.cursor = 'pointer';
					addListener(element, 'click', (e) => {
						if (!e.target.closest('.toast-close')) {
							options.onClick(toast);
						}
					});
				}
				
				if (options.pauseOnHover && duration > 0) {
					addListener(element, 'mouseenter', () => {
						toast.pause();
					});
					
					addListener(element, 'mouseleave', () => {
						toast.resume();
					});
				}
				
				toast.startTimer = () => {
					if (toast.remainingTime <= 0) return;
					
					toast.startTime = Date.now();
					toast.isPaused = false;
					
					toast.timerId = setTimeout(() => {
						this.hide(id);
					}, toast.remainingTime);
					
					if (options.showProgress) {
						const progressBar = element.querySelector('.toast-progress-bar');
						if (progressBar) {
							progressBar.style.transition = `width ${toast.remainingTime}ms linear`;
							requestAnimationFrame(() => {
								progressBar.style.width = '0%';
							});
						}
					}
				};
				
				toast.pause = () => {
					if (toast.isPaused || !toast.timerId) return;
					
					toast.isPaused = true;
					clearTimeout(toast.timerId);
					toast.timerId = null;
					
					const elapsed = Date.now() - toast.startTime;
					toast.remainingTime = Math.max(0, toast.remainingTime - elapsed);
					
					if (options.showProgress) {
						const progressBar = element.querySelector('.toast-progress-bar');
						if (progressBar && progressBar.parentElement) {
							const totalWidth = progressBar.parentElement.offsetWidth;
							if (totalWidth > 0) {
								const currentPercentage = (toast.remainingTime / duration) * 100;
								progressBar.style.transition = 'none';
								progressBar.style.width = `${currentPercentage}%`;
							}
						}
					}
				};
				
				toast.resume = () => {
					if (!toast.isPaused) return;
					toast.startTimer();
				};
				
				toast.cleanup = () => {
					if (toast.timerId) {
						clearTimeout(toast.timerId);
						toast.timerId = null;
					}
					
					toast.listeners.forEach(({ target, event, handler }) => {
						target.removeEventListener(event, handler);
					});
					toast.listeners = [];
				};
				
				return toast;
			},
			
			hide(toastId) {
				const toast = this.toasts.find(t => t.id === toastId);
				if (!toast || toast.isClosing) return;
				
				toast.isClosing = true;
				toast.cleanup();
				
				toast.element.classList.add('toast-exit');
				
				setTimeout(() => {
					this.removeToast(toastId);
				}, 300);
			},
			
			hideImmediate(toastId) {
				const toast = this.toasts.find(t => t.id === toastId);
				if (!toast) return;
				
				toast.isClosing = true;
				toast.cleanup();
				
				this.removeToast(toastId);
			},
			
			removeToast(toastId) {
				const index = this.toasts.findIndex(t => t.id === toastId);
				if (index === -1) return;
				
				const toast = this.toasts[index];
				
				if (toast.element.parentNode) {
					toast.element.remove();
				}
				
				this.toasts.splice(index, 1);
				
				if (this.toasts.length === 0 && this.container) {
					if (this.container.parentNode) {
						this.container.remove();
					}
					this.container = null;
				}
			},
			
			shake(element) {
				element.classList.add('toast-shake');
				setTimeout(() => {
					element.classList.remove('toast-shake');
				}, 500);
			},
			
			hideAll() {
				const toastIds = [...this.toasts.map(t => t.id)];
				toastIds.forEach(id => this.hide(id));
			},
			
			success(message, duration = 3000, options = {}) {
				return this.show(message, 'success', duration, options);
			},
			
			error(message, duration = 4000, options = {}) {
				return this.show(message, 'error', duration, options);
			},
			
			warning(message, duration = 4000, options = {}) {
				return this.show(message, 'warning', duration, options);
			},
			
			info(message, duration = 3000, options = {}) {
				return this.show(message, 'info', duration, options);
			}
		};

		/* ============================================================================
		   ğŸ” SMART SEARCH MANAGER
		   ============================================================================ */

		class SmartSearchManager {
			constructor(templateManager) {
				this.app = templateManager;
				
				this.searchSequence = 0;
				
				// =====================================================
				// CONFIGURATION
				// =====================================================
				this.config = {
					debounceDelay: 150,           // Debounce input
					minSearchLength: 1,           // Min chars to trigger
					maxResults: 8,                // Max results Ã®n dropdown
					maxCategoriesInBreakdown: 3,  // Max categories Ã®n found dropdown
					snippetLength: 120,           // Context around match
					snippetContextBefore: 40,     // Chars before match
					snippetContextAfter: 80,      // Chars after match
					highlightMatches: true,       // Enable highlighting
					showRelevanceBadges: true,    // Show Excellent/Good/Low
					showMatchTypes: true,         // Show Name/Content/Tags
					showCategoryBreakdown: true   // Show stats by category
				};
				
				// =====================================================
				// STATE
				// =====================================================
				this.state = {
					searchTerm: '',               // Raw search input
					searchTerms: [],              // Normalized split words
					isOpen: false,                // Dropdown visible
					hasResults: false,            // Any matches found
					totalSearched: 0,             // Total templates searched
					totalResults: 0,              // Total matches
					resultsByCategory: {},        // { categoryId: count }
					currentCategory: null,        // Active category context
					lastUpdate: null              // Timestamp
				};
				
				// =====================================================
				// DOM REFERENCES
				// =====================================================
				this.dom = {
					searchBar: null,
					clearBtn: null,
					container: null,
					dropdown: null
				};
				
				// =====================================================
				// EVENT HANDLERS (pentru cleanup)
				// =====================================================
				this.handlers = {
					input: null,
					focus: null,
					click: null,
					documentClick: null,
					clearClick: null,
					keydown: null
				};
				
				// =====================================================
				// DEBOUNCED SEARCH
				// =====================================================
				this.debouncedUpdate = Utils.debounce(
					this.performSearch.bind(this),
					this.config.debounceDelay
				);
			}
			
			/* ========================================================================
			   INITIALIZATION
			   ======================================================================== */
			
			/**
			 * Initialize SmartSearchManager
			 * @returns {boolean} Success status
			 */
			init() {
				try {
					// Find DOM elements
					this.dom.searchBar = document.getElementById('searchBar');
					this.dom.clearBtn = document.getElementById('searchClear');
					this.dom.container = document.querySelector('.search-container');
					
					if (!this.dom.searchBar || !this.dom.container) {
						console.error('SmartSearchManager: Required DOM elements not found');
						return false;
					}
					
					// Setup event listeners
					this.setupEventListeners();
					
					return true;
					
				} catch (error) {
					console.error('SmartSearchManager init failed:', error);
					return false;
				}
			}
			
			/* ========================================================================
			   EVENT LISTENERS
			   ======================================================================== */
			
			setupEventListeners() {
				const searchBar = this.dom.searchBar;
				const clearBtn = this.dom.clearBtn;
				
				// INPUT event - debounced search
				this.handlers.input = (e) => {
					const value = e.target.value;
					
					// Toggle clear button
					if (clearBtn) {
						clearBtn.toggleAttribute('hidden', !value.trim());
					}
					
					// Debounced search
					if (value.trim().length === 0) {
						this.close();
					} else {
						this.debouncedUpdate(value);
					}
				};
				
				// FOCUS event - show suggestions
				this.handlers.focus = () => {
					const value = searchBar.value.trim();
					
					if (value.length >= this.config.minSearchLength) {
						if (this.state.isOpen && this.state.searchTerm === value) {
							return;
						}
						this.performSearch(value);
					}
				};
				
				// CLICK on search bar - open dropdown if has value
				this.handlers.click = () => {
					const value = searchBar.value.trim();
					
					if (value.length >= this.config.minSearchLength && !this.state.isOpen) {
						this.performSearch(value);
					}
				};
				
				// CLEAR button click
				if (clearBtn) {
					this.handlers.clearClick = (e) => {
						e.preventDefault();
						e.stopPropagation();
						
						searchBar.value = '';
						this.app.searchTerm = '';
						
					if (this.debouncedUpdate && typeof this.debouncedUpdate.cancel === 'function') {
						this.debouncedUpdate.cancel();
					}
						
						this.app.renderTemplates();
						
						clearBtn.setAttribute('hidden', '');
						this.close();
						searchBar.focus();
						
						ToastManager.info('Search cleared', 1500);
					};
					
					clearBtn.addEventListener('click', this.handlers.clearClick);
				}
				
				// DOCUMENT click - close dropdown when clicking outside
				this.handlers.documentClick = (e) => {
					if (!e.target.closest('.search-container')) {
						this.close();
					}
				};
				
				// KEYBOARD shortcuts
				this.handlers.keydown = (e) => {
					// ESC - close dropdown
					if (e.key === 'Escape' && this.state.isOpen) {
						e.preventDefault();
						this.close();
						return;
					}
					
					// ENTER - select first result
					if (e.key === 'Enter' && this.state.isOpen && e.target === searchBar) {
						e.preventDefault();
						const firstResult = this.dom.dropdown?.querySelector('.search-result-item');
						if (firstResult) {
							firstResult.click();
						}
					}
				};
				
				// Attach listeners
				searchBar.addEventListener('input', this.handlers.input);
				searchBar.addEventListener('focus', this.handlers.focus);
				searchBar.addEventListener('click', this.handlers.click);
				searchBar.addEventListener('keydown', this.handlers.keydown);
				document.addEventListener('click', this.handlers.documentClick);
			}
			
			/* ========================================================================
			   CORE SEARCH (IDENTIC CU getFilteredTemplates)
			   ======================================================================== */
			
			/**
			 * Perform search using getFilteredTemplates logic
			 * @param {string} term - Search term
			 */
			performSearch(term) {
				try {
					const currentSequence = ++this.searchSequence;
					
					this.state.searchTerm = term.trim();
					this.state.lastUpdate = Date.now();
					
					// Update current category context
					this.state.currentCategory = this.app.activeCategory;
					
					if (this.state.searchTerm.length < this.config.minSearchLength) {
						this.close();
						return;
					}
					
					// ==========================================
					// NORMALIZARE + SPLIT
					// ==========================================
					const normalized = this.normalizeDiacritics(this.state.searchTerm.toLowerCase());
					this.state.searchTerms = normalized.split(/\s+/).filter(t => t.length > 0);
					
					if (this.state.searchTerms.length === 0) {
						this.close();
						return;
					}
					
					// ==========================================
					// GET TEMPLATES IN SCOPE
					// ==========================================
					let templates = [...this.app.templates];
					
					// Filter by active category (dacÄƒ nu e "toate")
					if (this.state.currentCategory && this.state.currentCategory !== 'toate') {
						templates = templates.filter(t => t.category === this.state.currentCategory);
					}
					
					this.state.totalSearched = templates.length;
					
					// ==========================================
					// NORMALIZE TEMPLATES
					// ==========================================
					const normalizedTemplates = templates.map(template => ({
						template: template,
						normalized: {
							name: this.normalizeDiacritics((template.name || '').toLowerCase()),
							content: this.normalizeDiacritics((template.content || '').toLowerCase()),
							tags: (template.tags || []).map(tag => 
								this.normalizeDiacritics((tag || '').toLowerCase())
							)
						}
					}));
					
					// ==========================================
					// MATCH cu AND Logic
					// ==========================================
					const matchedTemplates = normalizedTemplates.filter(item => {
						const combined = `${item.normalized.name} ${item.normalized.content} ${item.normalized.tags.join(' ')}`;
						
						// TOATE cuvintele trebuie prezente
						return this.state.searchTerms.every(term => combined.includes(term));
					});
					
					// ==========================================
					// SCORING
					// ==========================================
					const scored = matchedTemplates.map(item => {
						let score = 0;
						const matches = {
							name: [],
							content: [],
							tags: []
						};
						
						this.state.searchTerms.forEach(term => {
							// NAME: 100 base + bonuses
							if (item.normalized.name.includes(term)) {
								score += 100;
								matches.name.push(term);
								
								// Exact match
								if (item.normalized.name === term) {
									score += 100;
								}
								// Starts with
								else if (item.normalized.name.startsWith(term)) {
									score += 50;
								}
							}
							
							// CONTENT: 50 base
							if (item.normalized.content.includes(term)) {
								score += 50;
								matches.content.push(term);
							}
							
							// TAGS: 10 base + 5 exact
							const hasTagMatch = item.normalized.tags.some(tag => tag.includes(term));
							const hasExactTag = item.normalized.tags.some(tag => tag === term);
							
							if (hasTagMatch) {
								score += 10;
								matches.tags.push(term);
							}
							if (hasExactTag) {
								score += 5;
							}
						});
						
						return {
							template: item.template,
							score: score,
							matches: matches,
							normalized: item.normalized
						};
					});
					
					// ==========================================
					// SORT by RELEVANCE (DESC)
					// ==========================================
					const sorted = scored.sort((a, b) => b.score - a.score);
					
					if (currentSequence !== this.searchSequence) {
						// Un search mai nou a fost deja iniÈ›iat, ignorÄƒm aceste rezultate
						console.log(`SmartSearch: Ignoring stale search results (sequence ${currentSequence} vs ${this.searchSequence})`);
						return;
					}
					
					// ==========================================
					// CALCULATE STATS
					// ==========================================
					this.state.totalResults = sorted.length;
					this.state.hasResults = sorted.length > 0;
					
					this.state.resultsByCategory = this.calculateCategoryBreakdown(
						sorted.map(r => r.template)
					);
					
					// ==========================================
					// RENDER DROPDOWN
					// ==========================================
					this.renderDropdown(sorted.slice(0, this.config.maxResults));
					
				} catch (error) {
					console.error('SmartSearch performSearch error:', error);
					this.close();
				}
			}
			
			/**
			 * Normalize diacritics (Äƒâ†’a, Ã¢â†’a, Ã®â†’i, È™â†’s, È›â†’t)
			 * @param {string} text
			 * @returns {string}
			 */
			normalizeDiacritics(text) {
				if (!text) return '';
				
				const map = {
					'Äƒ': 'a', 'Ã¢': 'a', 'Ã®': 'i', 'È™': 's', 'È›': 't',
					'Ä‚': 'A', 'Ã‚': 'A', 'Ã': 'I', 'È˜': 'S', 'Èš': 'T',
					'Ã¡': 'a', 'Ã ': 'a', 'Ã¤': 'a', 'Ã©': 'e', 'Ã¨': 'e', 'Ã«': 'e',
					'Ã­': 'i', 'Ã¬': 'i', 'Ã¯': 'i', 'Ã³': 'o', 'Ã²': 'o', 'Ã¶': 'o',
					'Ãº': 'u', 'Ã¹': 'u', 'Ã¼': 'u', 'Ã±': 'n', 'Ã§': 'c'
				};
				
				return text.split('').map(c => map[c] || c).join('');
			}
			
			/**
			 * Calculate category breakdown
			 * @param {Array} templates - Matched templates
			 * @returns {Object} { categoryId: count }
			 */
			calculateCategoryBreakdown(templates) {
				const breakdown = {};
				
				templates.forEach(t => {
					if (t.category) {
						breakdown[t.category] = (breakdown[t.category] || 0) + 1;
					}
				});
				
				return breakdown;
			}
			
			/* ========================================================================
			   UI RENDERING
			   ======================================================================== */
			
			/**
			 * Render dropdown with search results
			 * @param {Array} results - Matched templates (max config.maxResults)
			 * @returns {boolean} Success status
			 */
			renderDropdown(results) {
				try {
					if (!Array.isArray(results)) {
						console.error('renderDropdown: results must be an array', results);
						return false;
					}
					
					if (!this.dom.container || !this.dom.container.parentNode) {
						console.error('renderDropdown: container element not found or not in DOM');
						return false;
					}
					
					this.close();
					
					const dropdown = document.createElement('div');
					dropdown.className = 'smart-search-dropdown';
					dropdown.setAttribute('role', 'listbox');
					dropdown.setAttribute('aria-label', `Search results for "${this.state.searchTerm}"`);
					
					// Stats header
					const statsHeader = this.renderStatsHeader();
					dropdown.appendChild(statsHeader);
					
					// Results or empty state (check PARAMETER not STATE)
					if (results.length === 0) {
						const emptyState = this.renderEmptyState();
						dropdown.appendChild(emptyState);
					} else {
						const resultsList = this.renderResults(results);
						dropdown.appendChild(resultsList);
					}
					
					this.dom.container.appendChild(dropdown);
					
					this.dom.dropdown = dropdown;
					this.state.isOpen = true;
					
					if (this.dom.searchBar) {
						this.dom.searchBar.setAttribute('aria-expanded', 'true');
					}
					
					return true;
					
				} catch (error) {
					console.error('renderDropdown error:', error);
					
					this.close();
					this.state.isOpen = false;
					
					ToastManager.error('Failed to display search results', 3000);
					
					return false;
				}
			}
			
			/**
			 * Render stats header with search results summary
			 * @returns {HTMLElement}
			 */
			renderStatsHeader() {
				const totalResults = typeof this.state.totalResults === 'number' && 
									!isNaN(this.state.totalResults) && 
									this.state.totalResults >= 0 
					? Math.floor(this.state.totalResults) 
					: 0;
				
				const totalSearched = typeof this.state.totalSearched === 'number' && 
									 !isNaN(this.state.totalSearched) && 
									 this.state.totalSearched >= 0 
					? Math.floor(this.state.totalSearched) 
					: 0;
				
				const categoryName = Utils.escapeHtml(this.getCategoryName(this.state.currentCategory));
				const categoryEmoji = this.getCategoryEmoji(this.state.currentCategory);
				
				const header = document.createElement('div');
				header.className = 'search-stats-header';
				
				const main = document.createElement('div');
				main.className = 'search-stats-main';
				main.setAttribute('role', 'status');
				main.setAttribute('aria-live', 'polite');
				main.setAttribute('aria-atomic', 'true');
				
				// Icon
				const icon = document.createElement('span');
				icon.className = 'stats-icon';
				icon.textContent = 'ğŸ”';
				icon.setAttribute('aria-hidden', 'true');
				
				// Text container
				const text = document.createElement('span');
				text.className = 'stats-text';
				
				// Results count (bold)
				const resultsStrong = document.createElement('strong');
				resultsStrong.textContent = totalResults.toString();
				
				// Searched count (bold)
				const searchedStrong = document.createElement('strong');
				searchedStrong.textContent = totalSearched.toString();
				
				// Category name (bold)
				const categoryStrong = document.createElement('strong');
				categoryStrong.textContent = categoryName;
				
				text.appendChild(resultsStrong);
				text.appendChild(document.createTextNode(' of '));
				text.appendChild(searchedStrong);
				text.appendChild(document.createTextNode(' in '));
				text.appendChild(document.createTextNode(categoryEmoji + ' '));
				text.appendChild(categoryStrong);
				
				// Assemble main
				main.appendChild(icon);
				main.appendChild(text);
				header.appendChild(main);
				
				const breakdownElement = this.renderCategoryBreakdown();
				
				// Only append if it has actual content
				if (breakdownElement && breakdownElement.childNodes && breakdownElement.childNodes.length > 0) {
					header.appendChild(breakdownElement);
				}
				
				return header;
			}
			
			/**
			 * Render category breakdown pentru search results
			 * @returns {DocumentFragment|HTMLElement}
			 */
			renderCategoryBreakdown() {
				if (!this.config.showCategoryBreakdown) {
					return document.createDocumentFragment();
				}
				
				if (this.state.currentCategory !== 'toate') {
					return document.createDocumentFragment();
				}
				
				if (!this.state.resultsByCategory || 
					typeof this.state.resultsByCategory !== 'object') {
					console.warn('resultsByCategory is invalid');
					return document.createDocumentFragment();
				}
				
				const entries = Object.entries(this.state.resultsByCategory)
					.filter(([_, count]) => count > 0); // Filter zero counts
				
				if (entries.length <= 1) {
					return document.createDocumentFragment();
				}
				
				const sorted = entries.sort((a, b) => b[1] - a[1]);
				const topCategories = sorted.slice(0, this.config.maxCategoriesInBreakdown);
				const remaining = Math.max(0, sorted.length - this.config.maxCategoriesInBreakdown);
				
				const categoryMap = new Map(
					(this.app.categories || []).map(cat => [cat.id, cat])
				);
				
				const container = document.createElement('div');
				container.className = 'search-category-breakdown';
				
				const label = document.createElement('div');
				label.className = 'breakdown-label';
				label.textContent = 'Found in:';
				
				const itemsContainer = document.createElement('div');
				itemsContainer.className = 'breakdown-items';
				
				const fragment = document.createDocumentFragment();
				
				topCategories.forEach(([catId, count], index) => {
					const category = categoryMap.get(catId);
					
					if (!category) {
						console.warn(`Category not found: ${catId}`);
					}
					
					const item = document.createElement('span');
					item.className = 'breakdown-item';
					item.setAttribute('data-category-id', catId);
					
					// Emoji + space
					const emoji = category?.emoji || 'ğŸ“';
					item.textContent = `${emoji} `;
					
					// Name (bold, truncated)
					const strong = document.createElement('strong');
					const name = category?.name || 'Unknown';
					strong.textContent = name.length > 20 
						? name.substring(0, 17) + '...' 
						: name;
					strong.title = name; // Full name on hover
					item.appendChild(strong);
					
					// Count
					const safeCount = typeof count === 'number' && !isNaN(count) ? Math.floor(count) : 0;
					item.appendChild(document.createTextNode(` (${safeCount})`));
					
					fragment.appendChild(item);
					
					// Separator
					if (index < topCategories.length - 1) {
						const separator = document.createTextNode(' â€¢ ');
						fragment.appendChild(separator);
					}
				});
				
				// "and X more" text
				if (remaining > 0) {
					const more = document.createElement('span');
					more.className = 'breakdown-more';
					more.textContent = ` and ${remaining} more`;
					more.title = `${remaining} additional ${remaining === 1 ? 'category' : 'categories'}`;
					fragment.appendChild(more);
				}
				
				itemsContainer.appendChild(fragment);
				container.appendChild(label);
				container.appendChild(itemsContainer);
				
				return container;
			}
			
			/**
			 * Render empty state for search
			 * @returns {HTMLElement}
			 */
			renderEmptyState() {
				const container = document.createElement('div');
				container.className = 'search-empty-state';
				container.setAttribute('role', 'status');
				container.setAttribute('aria-live', 'polite');
				
				try {
					const message = this.buildDetailedEmptyMessage();
					
					// Icon
					const iconDiv = document.createElement('div');
					iconDiv.className = 'empty-icon';
					iconDiv.setAttribute('aria-hidden', 'true');
					iconDiv.textContent = message.icon || 'ğŸ”';
					
					// Title (semantic h3)
					const titleDiv = document.createElement('h3');
					titleDiv.className = 'empty-title';
					titleDiv.textContent = message.title;
					
					// Message container
					const messageDiv = document.createElement('div');
					messageDiv.className = 'empty-message';
					messageDiv.innerHTML = message.content; // Safe dacÄƒ content e deja escapuit
					
					container.appendChild(iconDiv);
					container.appendChild(titleDiv);
					container.appendChild(messageDiv);
					
					return container;
					
				} catch (error) {
					console.error('renderEmptyState error:', error);
					
					const iconDiv = document.createElement('div');
					iconDiv.className = 'empty-icon';
					iconDiv.setAttribute('aria-hidden', 'true');
					iconDiv.textContent = 'âš ï¸';
					
					const titleDiv = document.createElement('h3');
					titleDiv.className = 'empty-title';
					titleDiv.textContent = 'Error';
					
					const messageDiv = document.createElement('div');
					messageDiv.className = 'empty-message';
					messageDiv.textContent = 'Unable to display results. Please try again.';
					
					container.appendChild(iconDiv);
					container.appendChild(titleDiv);
					container.appendChild(messageDiv);
					
					return container;
				}
			}

			/**
			 * Build detailed empty message
			 * @returns {Object} { icon, title, content }
			 */
			buildDetailedEmptyMessage() {
				if (!this.app || !Array.isArray(this.app.templates)) {
					console.error('Invalid app.templates');
					return {
						icon: 'âš ï¸',
						title: 'Error',
						content: 'Unable to load templates'
					};
				}
				
				const term = Utils.escapeHtml(this.state.searchTerm || '');
				const category = this.state.currentCategory;
				
				const categoryEmoji = this.getCategoryEmoji(category);
				
				const categoryName = Utils.escapeHtml(this.getCategoryName(category));
				const totalSearched = this.state.totalSearched || 0;
				
				const pluralize = (count, singular) => {
					const num = typeof count === 'number' && !isNaN(count) ? count : 0;
					return num === 1 ? singular : singular + 's';
				};
				
				// ==========================================
				// CASE 1: Search Ã®n categorie specificÄƒ
				// ==========================================
				if (category && category !== 'toate') {
					const otherResults = this.searchInOtherCategories();
					
					if (otherResults.length > 0) {
						const topCategories = this.getTopCategoriesHTML(otherResults, 3);
						
						return {
							icon: 'ğŸ”',
							title: 'No results in this category',
							content: `
								No templates match "<strong>${term}</strong>" in ${categoryEmoji} <strong>${categoryName}</strong>
								<br><br>
								ğŸ“Š Searched <strong>${totalSearched}</strong> ${pluralize(totalSearched, 'template')} in this category
								<br><br>
								ğŸ’¡ Found <strong>${otherResults.length}</strong> matching ${pluralize(otherResults.length, 'template')} in other categories:
								<br>
								ğŸ“‚ ${topCategories}
								<br><br>
								<em>Switch to "All Categories" to view these results</em>
							`
						};
					}
					
					return {
						icon: 'ğŸ”',
						title: 'No results found',
						content: `
							No templates match "<strong>${term}</strong>" in ${categoryEmoji} <strong>${categoryName}</strong>
							<br><br>
							ğŸ“Š Searched <strong>${totalSearched}</strong> ${pluralize(totalSearched, 'template')} in this category
							<br><br>
							ğŸ’­ No matches found in any category across <strong>${this.app.templates.length}</strong> total ${pluralize(this.app.templates.length, 'template')}
							<br><br>
							<em>ğŸ’¡ Try different keywords or create a new template</em>
						`
					};
				}
				
				// ==========================================
				// CASE 2: No templates exist
				// ==========================================
				const totalTemplates = this.app.templates.length;
				
				if (totalTemplates === 0) {
					return {
						icon: 'ğŸ“‹',
						title: 'No templates yet',
						content: `
							<strong>No templates exist yet</strong>
							<br><br>
							Create your first template to get started!
						`
					};
				}
				
				// ==========================================
				// CASE 3: Search Ã®n "toate" fÄƒrÄƒ rezultate
				// ==========================================
				const topCategories = this.getTopCategoriesByCount(3);
				
				const topCategoriesHTML = topCategories
					.map(c => `${c.emoji} <strong>${Utils.escapeHtml(c.name)}</strong> (${c.count})`)
					.join(', ');
				
				return {
					icon: 'ğŸ”',
					title: 'No templates found',
					content: `
						No templates match "<strong>${term}</strong>"
						<br><br>
						ğŸ“Š Searched across <strong>${totalTemplates}</strong> ${pluralize(totalTemplates, 'template')} in all categories
						${topCategoriesHTML ? `
							<br><br>
							ğŸ’¡ Try browsing by category:
							<br>
							ğŸ“‚ ${topCategoriesHTML}
						` : ''}
						<br><br>
						<em>Try different keywords or check for typos</em>
					`
				};
			}
			
			/**
			 * Render results list
			 * @param {Array} results
			 * @returns {HTMLElement}
			 */
			renderResults(results) {
				const container = document.createElement('div');
				container.className = 'search-results';
				
				const fragment = document.createDocumentFragment();
				
				results.forEach(result => {
					const item = this.createResultItem(result);
					fragment.appendChild(item);
				});
				
				container.appendChild(fragment);
				return container;
			}
			
			/**
			 * Create result item
			 * @param {Object} result - Result object cu { template, score, matches, normalized }
			 * @returns {HTMLElement} Result item element
			 */
			createResultItem(result) {
				const item = document.createElement('div');
				item.className = 'search-result-item';
				
				item.dataset.templateId = result.template.id;
				item.setAttribute('role', 'option');
				
				// Relevance badge
				const relevanceBadge = this.config.showRelevanceBadges 
					? this.getRelevanceBadge(result.score) 
					: '';
				
				// Match type indicator
				const matchType = this.config.showMatchTypes 
					? this.getMatchType(result.matches) 
					: '';
				
				// Category badge
				const categoryBadge = this.getCategoryBadgeHTML(result.template.category);
				
				// Snippet with context
				const snippet = this.getMatchSnippet(result);
				
				// Tags
				const tagsHTML = result.template.tags?.length > 0 
					? `<div class="result-tags">
							${result.template.tags.map(tag => 
								`<span class="tag">${this.highlightTerms(tag)}</span>`
							).join('')}
						</div>`
					: '';
				
				item.innerHTML = `
					<div class="result-header">
						<div class="result-title">
							${this.highlightTerms(result.template.name)}
							${relevanceBadge}
						</div>
						${matchType ? `<div class="result-match-type">${matchType}</div>` : ''}
					</div>
					<div class="result-category">${categoryBadge}</div>
					<div class="result-snippet">${snippet}</div>
					${tagsHTML}
				`;
				
				// Click handler
				item.addEventListener('click', () => this.selectResult(result.template));
				
				return item;
			}
			
			/* ========================================================================
			   HELPERS
			   ======================================================================== */
			
			/**
			 * Get relevance badge HTML
			 * @param {number} score
			 * @returns {string}
			 */
			getRelevanceBadge(score) {
				let level, label;
				
				if (score >= 200) {
					level = 'high';
					label = 'Excellent';
				} else if (score >= 100) {
					level = 'medium';
					label = 'Good';
				} else {
					level = 'low';
					label = 'Low';
				}
				
				return `<span class="relevance-badge relevance-${level}">${label}</span>`;
			}
			
			/**
			 * Get match type indicator
			 * @param {Object} matches - { name: [], content: [], tags: [] }
			 * @returns {string}
			 */
			getMatchType(matches) {
				const types = [];
				
				if (matches.name.length > 0) types.push('ğŸ“ Name');
				if (matches.content.length > 0) types.push('ğŸ“„ Content');
				if (matches.tags.length > 0) types.push('ğŸ·ï¸ Tags');
				
				return types.join(' â€¢ ');
			}
			
			/**
			 * Get category badge HTML
			 * @param {string} categoryId
			 * @returns {string}
			 */
			getCategoryBadgeHTML(categoryId) {
				const category = this.app.categories.find(c => c.id === categoryId);
				const emoji = category?.emoji || 'ğŸ“';
				const name = Utils.escapeHtml(category?.name || 'Unknown');
				
				return `<span class="category-badge">${emoji} ${name}</span>`;
			}
			
			/**
			 * Get match snippet with context
			 * @param {Object} result - Result object cu { template, matches, normalized }
			 * @returns {string} HTML snippet
			 */
			getMatchSnippet(result) {
				if (result.matches.content.length > 0) {
					return this.getContentSnippet(result);
				}
				
				// Fallback: truncated content
				const content = result.template.content || '';
				const truncated = content.length > this.config.snippetLength
					? content.substring(0, this.config.snippetLength) + '...'
					: content;
				
				return this.highlightTerms(truncated);
			}
			
			/**
			 * Get content snippet around match
			 * @param {Object} result - Result object cu { template, matches, normalized }
			 * @returns {string} HTML snippet with context
			 */
			getContentSnippet(result) {
				const firstTerm = this.state.searchTerms[0];
				
				const normalized = result.normalized.content;
				const matchIndex = normalized.indexOf(firstTerm);
				
				const content = result.template.content;
				
				if (matchIndex === -1) {
					const truncated = content.substring(0, this.config.snippetLength);
					return this.highlightTerms(truncated + (content.length > this.config.snippetLength ? '...' : ''));
				}
				
				// Calculate snippet range
				const matchEnd = matchIndex + firstTerm.length;
				const start = Math.max(0, matchIndex - this.config.snippetContextBefore);
				const end = Math.min(
					content.length,
					matchEnd + this.config.snippetContextAfter
				);
				
				let snippet = content.substring(start, end);
				
				if (start > 0) snippet = '...' + snippet;
				if (end < content.length) snippet += '...';
				
				return this.highlightTerms(snippet);
			}
			
			/**
			 * Highlight search terms Ã®n text (HTML-safe)
			 * @param {string} text - Textul de evidenÈ›iat
			 * @returns {string} HTML cu termenii evidenÈ›iaÈ›i
			 */
			highlightTerms(text) {
				if (!text || !this.config.highlightMatches || this.state.searchTerms.length === 0) {
					return Utils.escapeHtml(text);
				}
				
				try {
					const textLower = text.toLowerCase();
					const highlights = [];
					
					// Find all matches
					this.state.searchTerms.forEach(term => {
						const normalizedTerm = this.normalizeDiacritics(term.toLowerCase());
						const normalizedTextLower = this.normalizeDiacritics(textLower);
						
						let startIndex = 0;
						
						while ((startIndex = normalizedTextLower.indexOf(normalizedTerm, startIndex)) !== -1) {
							highlights.push({
								start: startIndex,
								end: startIndex + normalizedTerm.length
							});
							startIndex += normalizedTerm.length;
						}
					});
					
					if (highlights.length === 0) {
						return Utils.escapeHtml(text);
					}
					
					// Sort and merge overlapping
					highlights.sort((a, b) => a.start - b.start);
					
					const merged = [highlights[0]];
					for (let i = 1; i < highlights.length; i++) {
						const current = highlights[i];
						const last = merged[merged.length - 1];
						
						if (current.start <= last.end) {
							last.end = Math.max(last.end, current.end);
						} else {
							merged.push(current);
						}
					}
					
					// Build highlighted HTML
					let result = '';
					let lastEnd = 0;
					
					merged.forEach(({ start, end }) => {
						// Text before highlight
						if (start > lastEnd) {
							result += Utils.escapeHtml(text.substring(lastEnd, start));
						}
						
						// Highlighted text
						const matchedText = text.substring(start, end);
						result += `<strong class="highlight">${Utils.escapeHtml(matchedText)}</strong>`;
						
						lastEnd = end;
					});
					
					// Remaining text
					if (lastEnd < text.length) {
						result += Utils.escapeHtml(text.substring(lastEnd));
					}
					
					return result;
					
				} catch (error) {
					console.error('highlightTerms error:', error);
					return Utils.escapeHtml(text);
				}
			}
			
			/**
			 * Get category emoji
			 * @param {string} categoryId
			 * @returns {string}
			 */
			getCategoryEmoji(categoryId) {
				const category = this.app.categories.find(c => c.id === categoryId);
				return category?.emoji || 'ğŸ“';
			}
			
			/**
			 * Get category name
			 * @param {string} categoryId
			 * @returns {string}
			 */
			getCategoryName(categoryId) {
				const category = this.app.categories.find(c => c.id === categoryId);
				return category?.name || 'Unknown';
			}
			
			/**
			 * Search Ã®n alte categorii
			 * @returns {Array} Templates matched in other categories
			 */
			searchInOtherCategories() {
				if (!this.state.currentCategory || this.state.currentCategory === 'toate') {
					return [];
				}
				
				// Get all templates NOT Ã®n current category
				const otherTemplates = this.app.templates.filter(t => 
					t.category !== this.state.currentCategory
				);
				
				// Normalize
				const normalized = otherTemplates.map(t => ({
					original: t,
					name: this.normalizeDiacritics((t.name || '').toLowerCase()),
					content: this.normalizeDiacritics((t.content || '').toLowerCase()),
					tags: (t.tags || []).map(tag => this.normalizeDiacritics((tag || '').toLowerCase()))
				}));
				
				// Filter
				const matched = normalized.filter(n => {
					const combined = `${n.name} ${n.content} ${n.tags.join(' ')}`;
					return this.state.searchTerms.every(term => combined.includes(term));
				});
				
				return matched.map(n => n.original);
			}
			
			/**
			 * Get top categories HTML
			 * @param {Array} templates
			 * @param {number} limit
			 * @returns {string}
			 */
			getTopCategoriesHTML(templates, limit = 3) {
				const breakdown = {};
				
				templates.forEach(t => {
					breakdown[t.category] = (breakdown[t.category] || 0) + 1;
				});
				
				const sorted = Object.entries(breakdown)
					.sort((a, b) => b[1] - a[1])
					.slice(0, limit);
				
				return sorted
					.map(([catId, count]) => {
						const cat = this.app.categories.find(c => c.id === catId);
						return `${cat?.emoji || 'ğŸ“'} <strong>${Utils.escapeHtml(cat?.name || catId)}</strong> (${count})`;
					})
					.join(', ');
			}
			
			/**
			 * Get top categories by template count
			 * @param {number} limit
			 * @returns {Array}
			 */
			getTopCategoriesByCount(limit = 3) {
				const counts = {};
				
				this.app.templates.forEach(t => {
					if (t.category && t.category !== 'toate') {
						counts[t.category] = (counts[t.category] || 0) + 1;
					}
				});
				
				return Object.entries(counts)
					.sort((a, b) => b[1] - a[1])
					.slice(0, limit)
					.map(([catId, count]) => {
						const cat = this.app.categories.find(c => c.id === catId);
						return {
							id: catId,
							emoji: cat?.emoji || 'ğŸ“',
							name: cat?.name || catId,
							count
						};
					});
			}
			
			/* ========================================================================
			   USER INTERACTION
			   ======================================================================== */
			
			/**
			 * Handle result selection
			 * @param {Object} template
			 */
			selectResult(template) {
				try {
					const searchBar = this.dom.searchBar;
					
					// Set search to template name
					searchBar.value = template.name;
					this.app.searchTerm = template.name;
					this.app.renderTemplates();
					
					if (this.dom.clearBtn) {
						this.dom.clearBtn.removeAttribute('hidden');
					}
					
					// Scroll to card with flash
					setTimeout(() => {
						const card = document.querySelector(`[data-template-id="${template.id}"]`);
						if (card) {
							card.scrollIntoView({ behavior: 'smooth', block: 'center' });
							card.style.animation = 'none';
							requestAnimationFrame(() => {
								card.style.animation = 'flash 1s ease-out';
							});
						}
					}, 100);
					
					// Close dropdown
					this.close();
					searchBar.focus();
					
				} catch (error) {
					console.error('selectResult error:', error);
				}
			}
			
			/**
			 * Close dropdown
			 */
			close() {
				if (this.dom.dropdown) {
					this.dom.dropdown.remove();
					this.dom.dropdown = null;
				}
				this.state.isOpen = false;
			}
			
			/* ========================================================================
			   CLEANUP
			   ======================================================================== */
			
			/**
			 * Destroy instance and cleanup
			 */
			destroy() {
				try {
					// Cancel debounced
					if (this.debouncedUpdate?.cancel) {
						this.debouncedUpdate.cancel();
					}
					
					// Remove event listeners
					const searchBar = this.dom.searchBar;
					const clearBtn = this.dom.clearBtn;
					
					if (searchBar) {
						if (this.handlers.input) {
							searchBar.removeEventListener('input', this.handlers.input);
						}
						if (this.handlers.focus) {
							searchBar.removeEventListener('focus', this.handlers.focus);
						}
						if (this.handlers.click) {
							searchBar.removeEventListener('click', this.handlers.click);
						}
						if (this.handlers.keydown) {
							searchBar.removeEventListener('keydown', this.handlers.keydown);
						}
					}
					
					if (clearBtn && this.handlers.clearClick) {
						clearBtn.removeEventListener('click', this.handlers.clearClick);
					}
					
					if (this.handlers.documentClick) {
						document.removeEventListener('click', this.handlers.documentClick);
					}
					
					// Close dropdown
					this.close();
					
					// Clear references
					this.state = null;
					this.dom = null;
					this.handlers = null;
					this.app = null;
					
				} catch (error) {
					console.error('SmartSearchManager destroy error:', error);
				}
			}
		}
		
        /* ============================================================================
           ğŸ¯ MAIN APPLICATION CLASS
           ============================================================================ */
        
		class TemplateManager {
			/**
			 * Template Manager - gestioneazÄƒ templates È™i categorii
			 */
			constructor() {
				this.defaultCategories = [
					{ id: 'toate', name: 'Toate', emoji: 'ğŸ“', color: '#667eea' },
					{ id: 'intermediere', name: 'Intermediere', emoji: 'ğŸ‘¥', color: '#48bb78' },
					{ id: 'livrare', name: 'Livrare', emoji: 'ğŸšš', color: '#ed8936' },
					{ id: 'retur', name: 'Retur', emoji: 'ğŸ”„', color: '#38b2ac' },
					{ id: 'voucher', name: 'Voucher', emoji: 'ğŸ', color: '#9f7aea' },
					{ id: 'facturi', name: 'Facturi', emoji: 'ğŸ“„', color: '#f56565' },
					{ id: 'service', name: 'Service & GaranÈ›ii', emoji: 'âš™ï¸', color: '#4299e1' }
				];
				
				this.categoryColors = [
					'#48bb78', '#ed8936', '#38b2ac', '#9f7aea', '#f56565', '#4299e1', '#667eea',
					'#10b981', '#f59e0b', '#ec4899', '#8b5cf6', '#06b6d4', '#14b8a6', '#f97316',
					'#6366f1', '#84cc16', '#a855f7', '#22c55e', '#eab308', '#ef4444', '#3b82f6',
					'#0ea5e9', '#d946ef', '#fb923c', '#4ade80', '#facc15', '#fb7185', '#c084fc',
					'#34d399', '#fbbf24'
				];

				this.categoryEmojis = [
					'ğŸ“‚', 'ğŸ·ï¸', 'ğŸ“‹', 'ğŸ“Œ', 'ğŸ”–', 'ğŸ“', 'ğŸ“Š', 'ğŸ’¼', 'ğŸ¯', 'â­',
					'ğŸ“', 'ğŸ“„', 'ğŸ—‚ï¸', 'âœ…', 'âœ¨', 'ğŸŒŸ', 'âš¡', 'ğŸ”¥', 'ğŸ’', 'ğŸ¨',
					'ğŸ“¦', 'ğŸ', 'ğŸ› ï¸', 'âš™ï¸', 'ğŸ”‘', 'ğŸ†', 'ğŸ’°', 'ğŸ’µ', 'ğŸ“ˆ', 'ğŸ’¹',
					'ğŸ“§', 'ğŸ“¨', 'ğŸ’Œ', 'ğŸ“', 'ğŸ“…', 'ğŸ“†', 'â°', 'ğŸŒ', 'ğŸš€', 'âœˆï¸',
					'ğŸŒ±', 'ğŸŒ¸', 'ğŸŒˆ', 'â˜€ï¸', 'â˜•', 'ğŸ•', 'ğŸ˜Š', 'ğŸ’ª', 'ğŸ‘', 'â¡ï¸'
				];

				this.templates = [];
				this.categories = [];
				this.activeCategory = 'toate';
				this.searchTerm = '';
				this.smartSearch = null;
				this.editingTemplate = null;
				this.draggedTemplate = null;
				this.lastFocusedElement = null;
				this.storageEventListener = null;
				this.syncTimeout = null;
				
				/**
				 * Track drop targets pentru cleanup eficient
				 * @type {Set<HTMLElement>}
				 */
				this.currentDropTargets = new Set();
				
				/**
				 * Store event handlers pentru cleanup
				 * @type {Object}
				 */
				this.eventHandlers = {
					headerClick: null,
					categoryClick: null,
					addCategoryClick: null,
					searchInput: null,
					searchClear: null,
					searchEscape: null,
					emptyStateClick: null,
					templateGridClick: null,
					gridDragStart: null,
					gridDragEnd: null,
					gridDragOver: null,
					gridDragLeave: null,
					gridDrop: null,
					categoryDragEnter: null,
					categoryDragOver: null,
					categoryDragLeave: null,
					categoryDrop: null,
					modalMouseDown: null,
					modalMouseUp: null,
					modalClick: null,
					modalKeyDown: null,
					formSubmit: null,
					importChange: null,
					keyboardShortcuts: null
				};
				
				this.debouncedSearch = Utils.debounce(this.performSearch.bind(this), 150);
			}

			/**
			 * IniÈ›ializeazÄƒ aplicaÈ›ia
			 */
			async init() {
				let loadResult;
				
				try {
					loadResult = await this.loadData(true);
					
					if (!loadResult.success) {
						console.error('Data load failed:', {
							error: loadResult.error,
							usedDefaults: loadResult.usedDefaults
						});
						
						if (loadResult.usedDefaults) {
							ToastManager.warning('Could not load saved data. Starting fresh.', 4000);
						}
					} else if (loadResult.stats?.cleaned > 0) {
						console.log('Data loaded with cleanup:', loadResult.stats);
						ToastManager.info(
							`Removed ${loadResult.stats.cleaned} orphaned template${loadResult.stats.cleaned > 1 ? 's' : ''}.`,
							4000
						);
					}
					this.smartSearch = new SmartSearchManager(this);
					this.smartSearch.init();
				} catch (loadError) {
					console.error('Critical data load error:', loadError);
					
					this.templates = [];
					this.categories = [...this.defaultCategories];
					this.activeCategory = 'toate';
					
					ToastManager.warning('Could not load saved data. Starting fresh.', 4000);
				}
				
				try {
					this.renderUI({ all: true });
					this.setupEventListeners();
					this.setupStorageSync();
				} catch (renderError) {
					console.error('Critical render/setup error:', renderError);
					
					const shouldRefresh = await DialogManager.confirm({
						title: 'Critical Error',
						message: 'The application failed to initialize properly. A page refresh is recommended.\n\nError: ' + renderError.message,
						confirmText: 'Refresh Now',
						cancelText: 'Try Anyway',
						type: 'danger'
					});
					
					if (shouldRefresh) {
						window.location.reload();
					} else {
						console.warn('âš ï¸ User chose to continue despite critical error - app may be unstable');
						ToastManager.error('Application may be unstable. Consider refreshing.', 8000);
					}
				}
			}

			/**
			 * Sincronizare Ã®ntre tab-uri prin storage events
			 * Previne loop-uri infinite È™i gestioneazÄƒ conflicte de editare
			 */
			setupStorageSync() {
				if (this.storageEventListener) {
					window.removeEventListener('storage', this.storageEventListener);
				}
				
				if (this.syncTimeout) {
					clearTimeout(this.syncTimeout);
					this.syncTimeout = null;
				}
				
				const DEBOUNCE_DELAY = 300;
				const SYNC_KEYS = [StorageManager.KEYS.TEMPLATES, StorageManager.KEYS.CATEGORIES];
				let isSyncing = false;
				
				this.storageEventListener = (e) => {
					if (isSyncing) {
						console.log('Sync already in progress, skipping');
						return;
					}
					
					const isOurKey = e.key === null || SYNC_KEYS.includes(e.key);
					if (!isOurKey) return;
					
					if (this.syncTimeout) {
						clearTimeout(this.syncTimeout);
					}
					
					this.syncTimeout = setTimeout(async () => {
						isSyncing = true;
						
						try {
							// === MODAL OPEN: Limited Sync ===
							const modal = document.getElementById('templateModal');
							const isModalOpen = modal?.classList.contains('show');
							
							if (isModalOpen) {
								const editingId = this.editingTemplate?.id;
								
								console.warn('Sync with modal open - limited sync');
								
								await this.loadData(false);
								this.renderUI({ categorySelect: true });
								
								const templateExists = editingId && this.templates.some(t => t.id === editingId);
								
								if (editingId && !templateExists) {
									ToastManager.warning('Template deleted in another tab. Closing editor.', 5000);
									this.closeModal();
									this.renderUI({ all: true });
								} else if (editingId) {
									const currentTemplate = this.templates.find(t => t.id === editingId);
									const editingTemplate = this.editingTemplate;
									
									const wasModified = currentTemplate && (
										currentTemplate.name !== editingTemplate.name ||
										currentTemplate.content !== editingTemplate.content ||
										currentTemplate.category !== editingTemplate.category ||
										JSON.stringify(currentTemplate.tags) !== JSON.stringify(editingTemplate.tags)
									);
									
									if (wasModified) {
										const shouldReload = await DialogManager.confirm({
											title: 'Template Modified in Another Tab',
											message: `This template was modified elsewhere.\n\n` +
													`Current version: "${currentTemplate.name}"\n` +
													`Your version: "${editingTemplate.name}"\n\n` +
													`Do you want to reload the latest version?\n` +
													`(Your unsaved changes will be lost)`,
											confirmText: 'Reload Latest',
											cancelText: 'Keep Editing',
											type: 'warning'
										});
										
										if (shouldReload) {
											this.editingTemplate = currentTemplate;
											this.populateForm(currentTemplate);
											ToastManager.info('Form reloaded with latest data from other tab.', 4000);
										} else {
											ToastManager.warning('You are editing an outdated version. Saving will overwrite the latest changes.', 5000);
										}
									} else {
										ToastManager.info('Data synced from another tab (no conflicts).', 3000);
									}
								} else {
									ToastManager.warning('Data changed. Close editor to sync fully.', 5000);
								}
								
								return;
							}
							
							// === MODAL CLOSED: Full Sync ===
							const beforeSync = {
								templates: this.templates.length,
								categories: this.categories.length
							};
							
							await this.loadData(false);
							this.renderUI({ all: true });
							
							const changes = {
								templates: this.templates.length !== beforeSync.templates,
								categories: this.categories.length !== beforeSync.categories,
								cleared: e.key === null
							};
							
							const message = changes.cleared ? 'Storage cleared in another tab'
								: changes.templates && changes.categories ? 'Templates and categories synced'
								: changes.templates ? 'Templates synced'
								: changes.categories ? 'Categories synced'
								: 'Data synced from another tab';
							
							console.log('Sync complete:', message);
							ToastManager.info(message, 3000);
							
						} catch (error) {
							console.error('Sync error:', error);
							ToastManager.error('Sync failed. Please refresh the page.');
						} finally {
							isSyncing = false;
							this.syncTimeout = null;
						}
					}, DEBOUNCE_DELAY);
				};
				
				window.addEventListener('storage', this.storageEventListener);
			}

			/**
			 * ÃncarcÄƒ date din localStorage cu validare È™i cleanup automat
			 * @param {boolean} autoSave - If true, saves cleaned data back to storage
			 * @returns {Object} Load result object
			 */
			async loadData(autoSave = true) {
				try {
					const loadedCategories = StorageManager.load(
						StorageManager.KEYS.CATEGORIES,
						this.defaultCategories,
						Validators.validateCategories
					);
					
					this.categories = loadedCategories && loadedCategories.length > 0 
						? loadedCategories 
						: [...this.defaultCategories];
					
					const toateExists = this.categories.find(c => c.id === 'toate');
					if (!toateExists) {
						console.warn('Category "toate" missing after load, restoring default');
						this.categories.unshift({
							id: 'toate',
							name: 'Toate',
							emoji: 'ğŸ“',
							color: '#667eea'
						});
					}
					
					const loadedTemplates = StorageManager.load(
						StorageManager.KEYS.TEMPLATES,
						[],
						Validators.validateTemplates
					);
					
					this.templates = loadedTemplates || [];
					
					const categoryIds = new Set(this.categories.map(c => c.id));
					const initialCount = this.templates.length;
					
					this.templates = this.templates.filter(template => {
						const hasValidCategory = template.category && categoryIds.has(template.category);
						
						if (!hasValidCategory) {
							console.warn(`Removing orphaned template: ${template.id} (category: ${template.category})`);
						}
						
						return hasValidCategory;
					});
					
					const removed = initialCount - this.templates.length;
					
					if (removed > 0) {
						console.log(`Cleaned up ${removed} orphaned templates`);
						
						if (autoSave) {
							const saveResult = await this.saveData();
							
							if (!saveResult.success) {
								console.error('Failed to save cleaned data:', saveResult);
								return {
									success: false,
									message: 'Loaded data but failed to save cleanup changes',
									error: saveResult.error,
									stats: {
										templates: this.templates.length,
										categories: this.categories.length - 1,
										cleaned: removed
									}
								};
							}
						}
					}
					
					return {
						success: true,
						message: 'Data loaded successfully',
						stats: {
							templates: this.templates.length,
							categories: this.categories.length - 1,
							cleaned: removed
						}
					};
					
				} catch (error) {
					console.error('Failed to load data from storage:', error);
					
					this.templates = [];
					this.categories = [...this.defaultCategories];
					
					return {
						success: false,
						message: 'Failed to load data, using defaults',
						error: error.message || 'LOAD_ERROR',
						usedDefaults: true
					};
				}
			}

			/**
			 * SalveazÄƒ date Ã®n localStorage cu backup È™i rollback complet
			 * ReturneazÄƒ obiect cu status detaliat pentru gestionare granularÄƒ Ã®n funcÈ›iile apelante
			 * @returns {Object} { success: boolean, message: string, error?: string, critical?: boolean }
			 */
			async saveData() {
				try {
					const backup = {
						templates: JSON.parse(JSON.stringify(this.templates)),
						categories: JSON.parse(JSON.stringify(this.categories))
					};
					
					const templatesResult = StorageManager.save(
						StorageManager.KEYS.TEMPLATES,
						this.templates
					);

					if (!templatesResult.success) {
						if (templatesResult.error === 'QUOTA_EXCEEDED') {
							await this.handleQuotaExceeded();
							
							return {
								success: false,
								message: templatesResult.message || 'Storage quota exceeded. Please export your data and clean up old templates.',
								error: 'QUOTA_EXCEEDED',
								needsCleanup: true
							};
						}
						
						return {
							success: false,
							message: templatesResult.message || 'Failed to save templates to storage',
							error: templatesResult.error || 'UNKNOWN_ERROR'
						};
					}

					const categoriesResult = StorageManager.save(
						StorageManager.KEYS.CATEGORIES,
						this.categories
					);

					if (!categoriesResult.success) {
						console.warn('Categories save failed, initiating full rollback...');
						
						const templateRollback = StorageManager.save(
							StorageManager.KEYS.TEMPLATES,
							backup.templates
						);
						
						const categoryRollback = StorageManager.save(
							StorageManager.KEYS.CATEGORIES,
							backup.categories
						);
						
						this.templates = backup.templates;
						this.categories = backup.categories;
						
						if (!templateRollback.success || !categoryRollback.success) {
							console.error('CRITICAL: Rollback failed! Data may be inconsistent.');
							console.error('Template rollback:', templateRollback);
							console.error('Category rollback:', categoryRollback);
							
							return {
								success: false,
								message: 'Critical error: Failed to rollback data. Please refresh the page and verify your data integrity.',
								error: 'ROLLBACK_FAILED',
								critical: true
							};
						}
						
						console.log('Full rollback completed successfully');
						
						return {
							success: false,
							message: 'Failed to save categories. All data has been restored to the previous state.',
							error: categoriesResult.error || 'CATEGORIES_SAVE_FAILED',
							rolledBack: true
						};
					}

					return {
						success: true,
						message: 'Data saved successfully'
					};
					
				} catch (error) {
					console.error('Unexpected error during save:', error);
					
					return {
						success: false,
						message: 'An unexpected error occurred while saving data',
						error: error.message || 'UNEXPECTED_ERROR',
						exception: error
					};
				}
			}

			/**
			 * Gestionare storage quota exceeded
			 */
			async handleQuotaExceeded() {
				try {
					const storageSize = StorageManager.getSize();
					const sizeMB = (storageSize / (1024 * 1024)).toFixed(2);
					
					const confirmed = await DialogManager.confirm({
						title: 'Storage Full',
						message: `Your storage is full (${sizeMB} MB used). Would you like to export your data as backup?`,
						confirmText: 'Export Data',
						cancelText: 'Cancel',
						type: 'warning'
					});

					if (confirmed) {
						try {
							this.exportData();
							
							const cleanup = await DialogManager.confirm({
								title: 'Cleanup Storage',
								message: 'Data exported successfully. Do you want to delete old templates to free up space?',
								confirmText: 'Show Cleanup Options',
								cancelText: 'Not Now',
								type: 'default'
							});
							
							if (cleanup) {
								const sortedTemplates = [...this.templates].sort((a, b) => {
									const dateA = new Date(a.createdAt || 0);
									const dateB = new Date(b.createdAt || 0);
									return dateA - dateB;
								});
								
								const oldestCount = Math.min(10, sortedTemplates.length);
								
								const reviewConfirmed = await DialogManager.confirm({
									title: 'Cleanup Suggestions',
									message: `You have ${this.templates.length} templates. Consider deleting the oldest ${oldestCount} templates to free up space.`,
									confirmText: 'Review Templates',
									cancelText: 'Cancel',
									type: 'default'
								});
								
								if (reviewConfirmed) {
									const confirmDelete = await DialogManager.confirm({
										title: 'Confirm Deletion',
										message: `Delete the ${oldestCount} oldest templates?\n\nThis action cannot be undone.`,
										confirmText: 'Delete',
										cancelText: 'Cancel',
										type: 'danger'
									});
									
									if (confirmDelete) {
										const toDelete = sortedTemplates.slice(0, oldestCount);
										const idsToDelete = new Set(toDelete.map(t => t.id));
										
										const backup = [...this.templates];
										this.templates = this.templates.filter(t => !idsToDelete.has(t.id));
										
										const saveResult = await this.saveData();
										
										if (saveResult.success) {
											this.activeCategory = 'toate';
											this.searchTerm = '';
											this.renderUI({ all: true });
											ToastManager.success(`Deleted ${oldestCount} old templates. Storage freed.`, 5000);
										} else {
											this.templates = backup;
											this.renderUI({ all: true });
											ToastManager.error('Failed to delete templates. Please try manual deletion.', 5000);
										}
									}
								}
							}
							
						} catch (exportError) {
							console.error('Export failed:', exportError);
							ToastManager.error('Failed to export data. Please try manual export.');
						}
					}
					
				} catch (error) {
					console.error('Error handling quota exceeded:', error);
					ToastManager.error('An error occurred. Please try exporting data manually.');
				}
			}

			/* ========================================================================
			   ğŸ§ EVENT LISTENERS SETUP
			   ======================================================================== */

			/**
			 * ConfigureazÄƒ toate event listeners pentru aplicaÈ›ie
			 */
			setupEventListeners() {
				const setupFunctions = [
					{ name: 'Header', fn: this.setupHeaderListeners },
					{ name: 'Categories', fn: this.setupCategoryListeners },
					{ name: 'Search', fn: this.setupSearchListener },
					{ name: 'Empty State', fn: this.setupEmptyStateListeners },
					{ name: 'Templates', fn: this.setupTemplateListeners },
					{ name: 'Drag & Drop', fn: this.setupDragDropListeners },
					{ name: 'Modal', fn: this.setupModalListeners },
					{ name: 'Import', fn: this.setupImportListener },
					{ name: 'Keyboard Shortcuts', fn: this.setupKeyboardShortcuts }
				];
				
				const failed = [];
				
				setupFunctions.forEach(({ name, fn }) => {
					try {
						fn.call(this);
					} catch (error) {
						console.error(`Failed to setup ${name} listeners:`, error);
						failed.push(name);
					}
				});
				
				if (failed.length > 0) {
					ToastManager.warning(
						`Some features may not work: ${failed.join(', ')}. Try refreshing the page.`,
						6000
					);
				}
			}

			/**
			 * ConfigureazÄƒ event listeners pentru header actions
			 */
			setupHeaderListeners() {
				try {
					const headerActions = document.querySelector('.header-actions');
					
					if (!headerActions) {
						console.warn('Header actions container (.header-actions) not found in DOM. Verify HTML structure.');
						return;
					}
					
					if (this.eventHandlers.headerClick) {
						headerActions.removeEventListener('click', this.eventHandlers.headerClick);
					}
					
					this.eventHandlers.headerClick = (e) => {
						try {
							const button = e.target.closest('button[data-action]');
							if (!button) return;

							const action = button.dataset.action;
							
							if (!action) {
								console.warn('Button missing data-action attribute');
								return;
							}
							
							switch (action) {
								case 'export':
									try {
										this.exportData();
									} catch (error) {
										console.error('Export action error:', error);
										ToastManager.error('Export failed. Please try again.');
									}
									break;
								case 'add-template':
									try {
										this.openModal();
									} catch (error) {
										console.error('Add template action error:', error);
										ToastManager.error('Failed to open template editor.');
									}
									break;
								default:
									console.warn(`Unknown header action: ${action}`);
									ToastManager.warning(`Action "${action}" is not recognized.`);
							}
						} catch (error) {
							console.error('Header click handler error:', error);
							ToastManager.error('Action failed. Please try again.');
						}
					};
					
					headerActions.addEventListener('click', this.eventHandlers.headerClick);
					
				} catch (error) {
					console.error('Failed to setup header listeners:', error);
				}
			}

			/**
			 * ConfigureazÄƒ event listeners pentru category list È™i add button
			 */
			setupCategoryListeners() {
				try {
					const categoryList = document.getElementById('categoryList');
					const addCategoryBtn = document.querySelector('.add-category');

					if (!categoryList) {
						console.warn('Category list not found');
						return;
					}
					
					if (!addCategoryBtn) {
						console.warn('Add category button not found');
						return;
					}
					
					if (this.eventHandlers.categoryClick) {
						categoryList.removeEventListener('click', this.eventHandlers.categoryClick);
					}
					
					if (this.eventHandlers.addCategoryClick) {
						addCategoryBtn.removeEventListener('click', this.eventHandlers.addCategoryClick);
					}

					this.eventHandlers.categoryClick = (e) => {
						try {
							const categoryItem = e.target.closest('.category-item');
							if (categoryItem && !e.target.closest('.category-btn')) {
								const categoryId = categoryItem.dataset.categoryId;
								if (categoryId) {
									this.setActiveCategory(categoryId);
								}
								return;
							}

							const actionBtn = e.target.closest('.category-btn');
							if (actionBtn) {
								e.stopPropagation();
								
								const action = actionBtn.dataset.action;
								const categoryItemEl = actionBtn.closest('.category-item');
								
								if (!categoryItemEl) {
									console.warn('Category item not found for action button');
									return;
								}
								
								const categoryId = categoryItemEl.dataset.categoryId;
								
								if (!categoryId) {
									console.warn('Category ID missing');
									return;
								}
								
								if (action === 'edit') {
									try {
										this.editCategory(categoryId);
									} catch (error) {
										console.error('Edit category error:', error);
										ToastManager.error('Failed to edit category. Please try again.');
									}
								} else if (action === 'delete') {
									try {
										this.deleteCategory(categoryId);
									} catch (error) {
										console.error('Delete category error:', error);
										ToastManager.error('Failed to delete category. Please try again.');
									}
								} else {
									console.warn(`Unknown category action: ${action}`);
								}
							}
						} catch (error) {
							console.error('Category click handler error:', error);
							ToastManager.error('Category action failed. Please try again.');
						}
					};

					this.eventHandlers.addCategoryClick = () => {
						try {
							this.addNewCategory();
						} catch (error) {
							console.error('Add category handler error:', error);
							ToastManager.error('Failed to add category. Please try again.');
						}
					};

					categoryList.addEventListener('click', this.eventHandlers.categoryClick);
					addCategoryBtn.addEventListener('click', this.eventHandlers.addCategoryClick);
					
				} catch (error) {
					console.error('Failed to setup category listeners:', error);
				}
			}

			/**
			 * ConfigureazÄƒ debounced search listener
			 */
			setupSearchListener() {
				try {
					const searchBar = document.getElementById('searchBar');
					const searchClear = document.getElementById('searchClear');
					
					if (!searchBar) {
						console.warn('Search bar (#searchBar) not found in DOM. Search functionality disabled.');
						return;
					}
					
					if (this.eventHandlers.searchInput) {
						searchBar.removeEventListener('input', this.eventHandlers.searchInput);
					}
					
					if (this.eventHandlers.searchClear && searchClear) {
						searchClear.removeEventListener('click', this.eventHandlers.searchClear);
					}
					
					if (this.eventHandlers.searchEscape) {
						searchBar.removeEventListener('keydown', this.eventHandlers.searchEscape);
					}
					
					this.eventHandlers.searchInput = (e) => {
						try {
							const value = e.target.value;
							const hasValue = value.trim().length > 0;
							
							if (searchClear) {
								searchClear.toggleAttribute('hidden', !hasValue);
							}
							
							this.debouncedSearch(value);
						} catch (error) {
							console.error('Search input handler error:', error);
						}
					};
					
					this.eventHandlers.searchClear = () => {
						this.clearSearch();
					};
					
					this.eventHandlers.searchEscape = (e) => {
						if (e.key === 'Escape') {
							const modal = document.getElementById('templateModal');
							const isModalOpen = modal && modal.classList.contains('show');
							
							if (isModalOpen) {
								return;
							}
							
							if (searchBar.value.trim()) {
								e.preventDefault();
								this.clearSearch();
							}
						}
					};
					
					searchBar.addEventListener('input', this.eventHandlers.searchInput);
					
					if (searchClear) {
						searchClear.addEventListener('click', this.eventHandlers.searchClear);
					}
					
					searchBar.addEventListener('keydown', this.eventHandlers.searchEscape);
					
				} catch (error) {
					console.error('Failed to setup search listener:', error);
				}
			}

			/**
			 * ExecutÄƒ cÄƒutarea È™i re-renderizeazÄƒ templates
			 * @param {string} term
			 */
			performSearch(term) {
				try {
					if (!this.templates || !Array.isArray(this.templates)) {
						console.warn('Templates not available for search');
						return;
					}
					
					this.searchTerm = term;
					this.renderUI({ templates: true });
				} catch (error) {
					console.error('Search execution error:', error);
					ToastManager.error('Search failed. Please try again.');
				}
			}
			
			/**
			 * È˜terge conÈ›inutul cÃ¢mpului de cÄƒutare È™i reseteazÄƒ starea cÄƒutÄƒrii.
			 */
			clearSearch() {
				try {
					const searchBar = document.getElementById('searchBar');
					const searchClear = document.getElementById('searchClear');
					
					if (searchBar) {
						searchBar.value = '';
						searchBar.focus();
					}
					
					if (searchClear) {
						searchClear.setAttribute('hidden', '');
					}
					
					this.performSearch('');
				} catch (error) {
					console.error('Clear search error:', error);
					ToastManager.error('Failed to clear search.');
				}
			}

			/**
			 * ConfigureazÄƒ event delegation pentru empty state actions
			 */
			setupEmptyStateListeners() {
				try {
					const grid = document.getElementById('templatesGrid');
					
					if (!grid) {
						console.warn('Templates grid not found for empty state listeners');
						return;
					}
					
					if (this.eventHandlers.emptyStateClick) {
						grid.removeEventListener('click', this.eventHandlers.emptyStateClick);
					}
					
					this.eventHandlers.emptyStateClick = (e) => {
						try {
							const button = e.target.closest('[data-empty-action]');
							if (!button) return;
							
							e.stopPropagation();
							
							const action = button.dataset.emptyAction;
							
							switch (action) {
								case 'clear-search':
									this.clearSearch();
									break;
									
								case 'search-all':
									this.setActiveCategory('toate');
									break;
									
								case 'create-template':
								case 'add-template':
									this.openModal();
									break;
									
								case 'view-all':
									this.setActiveCategory('toate');
									break;
									
								default:
									console.warn(`Unknown empty state action: ${action}`);
							}
						} catch (error) {
							console.error('Empty state action error:', error);
							ToastManager.error('Action failed. Please try again.');
						}
					};
					
					grid.addEventListener('click', this.eventHandlers.emptyStateClick);
					
				} catch (error) {
					console.error('Failed to setup empty state listeners:', error);
				}
			}

			/**
			 * ConfigureazÄƒ event delegation pentru template actions
			 */
			setupTemplateListeners() {
				try {
					const grid = document.getElementById('templatesGrid');

					if (!grid) {
						console.warn('Templates grid (#templatesGrid) not found in DOM. Template display disabled.');
						return;
					}
					
					if (this.eventHandlers.templateGridClick) {
						grid.removeEventListener('click', this.eventHandlers.templateGridClick);
					}

					this.eventHandlers.templateGridClick = (e) => {
						try {
							const actionBtn = e.target.closest('.template-actions button');
							if (!actionBtn) return;
							
							e.stopPropagation();

							const action = actionBtn.dataset.action;
							const card = actionBtn.closest('.template-card');
							
							if (!card) {
								console.warn('Template card not found for action button');
								return;
							}
							
							const templateId = card.dataset.templateId;
							
							if (!templateId) {
								console.warn('Template ID missing');
								return;
							}

							this.handleTemplateAction(action, templateId);
						} catch (error) {
							console.error('Template action handler error:', error);
							ToastManager.error('Template action failed. Please try again.');
						}
					};

					grid.addEventListener('click', this.eventHandlers.templateGridClick);
					
				} catch (error) {
					console.error('Failed to setup template listeners:', error);
				}
			}

			/**
			 * Dispatcher pentru template actions
			 * @param {string} action
			 * @param {string} templateId
			 */
			handleTemplateAction(action, templateId) {
				try {
					if (!templateId) {
						console.error('Template ID is required for action:', action);
						ToastManager.error('Invalid template. Please refresh the page.');
						return;
					}
					
					const template = this.templates.find(t => t.id === templateId);
					if (!template) {
						console.warn(`Template ${templateId} not found for action ${action}`);
						ToastManager.warning('Template no longer exists. Refreshing view...');
						this.renderUI({ templates: true });
						return;
					}
					
					switch (action) {
						case 'copy':
							try {
								this.copyTemplateContent(templateId);
							} catch (error) {
								console.error('Copy template error:', error);
								ToastManager.error('Failed to copy template content.');
							}
							break;
						case 'edit':
							try {
								this.editTemplate(templateId);
							} catch (error) {
								console.error('Edit template error:', error);
								ToastManager.error('Failed to open template editor.');
							}
							break;
						case 'delete':
							try {
								this.deleteTemplate(templateId);
							} catch (error) {
								console.error('Delete template error:', error);
								ToastManager.error('Failed to delete template.');
							}
							break;
						default:
							console.warn(`Unknown template action: ${action}`);
							ToastManager.warning(`Template action "${action}" is not supported.`);
					}
				} catch (error) {
					console.error('Template action dispatcher error:', error);
					ToastManager.error('Action failed. Please try again.');
				}
			}

			/**
			 * ConfigureazÄƒ drag and drop pentru reordonare templates
			 */
			setupDragDropListeners() {
				try {
					const grid = document.getElementById('templatesGrid');

					if (!grid) {
						console.warn('Templates grid not found for drag & drop');
						return;
					}
					
					if (this.eventHandlers.gridDragStart) {
						grid.removeEventListener('dragstart', this.eventHandlers.gridDragStart);
					}
					if (this.eventHandlers.gridDragEnd) {
						grid.removeEventListener('dragend', this.eventHandlers.gridDragEnd);
					}
					if (this.eventHandlers.gridDragOver) {
						grid.removeEventListener('dragover', this.eventHandlers.gridDragOver);
					}
					if (this.eventHandlers.gridDragLeave) {
						grid.removeEventListener('dragleave', this.eventHandlers.gridDragLeave);
					}
					if (this.eventHandlers.gridDrop) {
						grid.removeEventListener('drop', this.eventHandlers.gridDrop);
					}

					this.eventHandlers.gridDragStart = (e) => {
						try {
							if (e.target.closest('.template-actions button')) {
								return;
							}
							
							const card = e.target.closest('.template-card[draggable="true"]');
							if (!card) return;

							const templateId = card.dataset.templateId;
							if (!templateId) {
								console.warn('Template ID missing on draggable card');
								return;
							}

							this.draggedTemplate = templateId;
							e.dataTransfer.effectAllowed = 'move';
							e.dataTransfer.setData('text/plain', templateId);
							card.classList.add('dragging');
							document.body.classList.add('is-dragging');
						} catch (error) {
							console.error('Drag start handler error:', error);
						}
					};

					this.eventHandlers.gridDragEnd = (e) => {
						try {
							const card = e.target.closest('.template-card');
							if (card) {
								card.classList.remove('dragging');
							}
							
							if (!this.draggedTemplate) {
								return;
							}
							
							const draggedCard = document.querySelector(`[data-template-id="${this.draggedTemplate}"]`);
							if (draggedCard) {
								draggedCard.classList.remove('dragging');
							}
							
							this.clearDropTargets();
							
							this.draggedTemplate = null;
							document.body.classList.remove('is-dragging');
						} catch (error) {
							console.error('Drag end handler error:', error);
							
							this.draggedTemplate = null;
							document.body.classList.remove('is-dragging');
							
							if (this.currentDropTargets) {
								this.currentDropTargets.clear();
							} else {
								this.currentDropTargets = new Set();
							}
						}
					};

					this.eventHandlers.gridDragOver = (e) => {
						try {
							const card = e.target.closest('.template-card');
							if (!card || !this.draggedTemplate) return;

							const targetId = card.dataset.templateId;
							if (!targetId) return;

							if (!this.currentDropTargets) {
								this.currentDropTargets = new Set();
							}

							if (this.draggedTemplate !== targetId) {
								const draggedTemplate = this.templates.find(t => t.id === this.draggedTemplate);
								const targetTemplate = this.templates.find(t => t.id === targetId);

								if (draggedTemplate && targetTemplate && 
									draggedTemplate.category !== targetTemplate.category) {
									e.preventDefault();
									e.dataTransfer.dropEffect = 'none';
									card.classList.add('drop-forbidden');
									this.currentDropTargets.add(card);
									return;
								}

								e.preventDefault();
								e.dataTransfer.dropEffect = 'move';
								card.classList.add('drop-target');
								this.currentDropTargets.add(card);
							}
						} catch (error) {
							console.error('Drag over handler error:', error);
						}
					};

					this.eventHandlers.gridDragLeave = (e) => {
						try {
							const card = e.target.closest('.template-card');
							if (!card) return;

							if (!this.currentDropTargets) {
								this.currentDropTargets = new Set();
								return;
							}

							if (!card.contains(e.relatedTarget)) {
								card.classList.remove('drop-target', 'drop-forbidden');
								this.currentDropTargets.delete(card);
							}
						} catch (error) {
							console.error('Drag leave handler error:', error);
						}
					};

					this.eventHandlers.gridDrop = async (e) => {
						try {
							e.preventDefault();
							const card = e.target.closest('.template-card');
							if (!card) return;

							card.classList.remove('drop-target', 'drop-forbidden');
							this.currentDropTargets.delete(card);

							const draggedId = e.dataTransfer.getData('text/plain');
							const targetId = card.dataset.templateId;

							if (!draggedId || !targetId) {
								console.warn('Missing template IDs for drop operation');
								return;
							}

							if (draggedId !== targetId) {
								const draggedTemplate = this.templates.find(t => t.id === draggedId);
								const targetTemplate = this.templates.find(t => t.id === targetId);
								
								if (!draggedTemplate || !targetTemplate) {
									console.warn('Template(s) not found - may have been deleted');
									ToastManager.warning('Template no longer exists. Refreshing...', 3000);
									
									await this.loadData(false);
									this.renderUI({ templates: true });
									
									return;
								}
								
								if (draggedTemplate.category !== targetTemplate.category) {
									console.log('Cannot reorder templates from different categories');
									ToastManager.info('Cannot reorder templates from different categories');
									return;
								}
								
								const position = this.getDropPosition(e, card);
								await this.reorderTemplates(draggedId, targetId, position);
							}
						} catch (error) {
							console.error('Drop handler error:', error);
							ToastManager.error('Failed to reorder templates.');
						}
					};

					grid.addEventListener('dragstart', this.eventHandlers.gridDragStart);
					grid.addEventListener('dragend', this.eventHandlers.gridDragEnd);
					grid.addEventListener('dragover', this.eventHandlers.gridDragOver);
					grid.addEventListener('dragleave', this.eventHandlers.gridDragLeave);
					grid.addEventListener('drop', this.eventHandlers.gridDrop);

					this.setupCategoryDropZones();
					
				} catch (error) {
					console.error('Failed to setup drag & drop listeners:', error);
				}
			}

			/**
			 * ConfigureazÄƒ drag & drop zones pentru categorii
			 */
			setupCategoryDropZones() {
				try {
					const categoryList = document.getElementById('categoryList');

					if (!categoryList) {
						console.warn('Category list not found for drop zones');
						return;
					}

					if (this.eventHandlers.categoryDragOver) {
						categoryList.removeEventListener('dragover', this.eventHandlers.categoryDragOver);
					}
					if (this.eventHandlers.categoryDragEnter) {
						categoryList.removeEventListener('dragenter', this.eventHandlers.categoryDragEnter);
					}
					if (this.eventHandlers.categoryDragLeave) {
						categoryList.removeEventListener('dragleave', this.eventHandlers.categoryDragLeave);
					}
					if (this.eventHandlers.categoryDrop) {
						categoryList.removeEventListener('drop', this.eventHandlers.categoryDrop);
					}

					this.eventHandlers.categoryDragOver = (e) => {
						try {
							const categoryItem = e.target.closest('.category-item');
							if (!categoryItem) return;
							
							const categoryId = categoryItem.dataset.categoryId;
							
							if (!categoryId || categoryId === 'toate') {
								e.preventDefault();
								e.dataTransfer.dropEffect = 'none';
								return;
							}

							if (this.draggedTemplate) {
								const template = this.templates.find(t => t.id === this.draggedTemplate);
								if (template && template.category === categoryId) {
									e.preventDefault();
									e.dataTransfer.dropEffect = 'none';
									return;
								}
							}

							e.preventDefault();
							e.dataTransfer.dropEffect = 'move';
						} catch (error) {
							console.error('Category drag over handler error:', error);
						}
					};

					this.eventHandlers.categoryDragEnter = (e) => {
						try {
							const categoryItem = e.target.closest('.category-item');
							if (!categoryItem) return;
							
							const categoryId = categoryItem.dataset.categoryId;
							
							if (!this.currentDropTargets) {
								this.currentDropTargets = new Set();
							}
							
							if (!categoryId || categoryId === 'toate') {
								e.preventDefault();
								categoryItem.classList.add('drop-forbidden');
								this.currentDropTargets.add(categoryItem);
								return;
							}
							
							if (this.draggedTemplate) {
								const template = this.templates.find(t => t.id === this.draggedTemplate);
								if (template && template.category === categoryId) {
									e.preventDefault();
									categoryItem.classList.add('drop-forbidden');
									this.currentDropTargets.add(categoryItem);
									return;
								}
							}

							e.preventDefault();
							categoryItem.classList.add('drag-over');
							this.currentDropTargets.add(categoryItem);
						} catch (error) {
							console.error('Category drag enter handler error:', error);
						}
					};

					this.eventHandlers.categoryDragLeave = (e) => {
						try {
							const categoryItem = e.target.closest('.category-item');
							if (!categoryItem) return;

							if (!this.currentDropTargets) {
								this.currentDropTargets = new Set();
								return;
							}

							if (!categoryItem.contains(e.relatedTarget)) {
								categoryItem.classList.remove('drag-over', 'drop-forbidden');
								this.currentDropTargets.delete(categoryItem);
							}
						} catch (error) {
							console.error('Category drag leave handler error:', error);
						}
					};

					this.eventHandlers.categoryDrop = async (e) => {
						try {
							e.preventDefault();
							const categoryItem = e.target.closest('.category-item');
							if (!categoryItem) return;

							categoryItem.classList.remove('drag-over', 'drop-forbidden');
							this.currentDropTargets.delete(categoryItem);

							const templateId = e.dataTransfer.getData('text/plain');
							const categoryId = categoryItem.dataset.categoryId;

							if (!templateId || !categoryId) {
								console.warn('Missing IDs for category drop');
								return;
							}
							
							if (categoryId === 'toate') {
								console.log('Cannot move to "toate" category');
								return;
							}
							
							const template = this.templates.find(t => t.id === templateId);
							
							if (!template) {
								console.warn('Template not found - may have been deleted');
								ToastManager.warning('Template no longer exists. Refreshing...', 3000);
								
								await this.loadData(false);
								this.renderUI({ templates: true });
								
								return;
							}
							
							if (template.category === categoryId) {
								console.log('Template already in target category');
								return;
							}
							
							this.moveTemplateToCategory(templateId, categoryId);
						} catch (error) {
							console.error('Category drop handler error:', error);
							ToastManager.error('Failed to move template to category.');
						}
					};

					categoryList.addEventListener('dragover', this.eventHandlers.categoryDragOver);
					categoryList.addEventListener('dragenter', this.eventHandlers.categoryDragEnter);
					categoryList.addEventListener('dragleave', this.eventHandlers.categoryDragLeave);
					categoryList.addEventListener('drop', this.eventHandlers.categoryDrop);
					
				} catch (error) {
					console.error('Failed to setup category drop zones:', error);
				}
			}

			/**
			 * CalculeazÄƒ poziÈ›ia de drop relativÄƒ la card
			 * @param {DragEvent} event
			 * @param {HTMLElement} card
			 * @returns {string}
			 */
			getDropPosition(event, card) {
				try {
					const cardRect = card.getBoundingClientRect();
					const mouseY = event.clientY;
					const cardMiddleY = cardRect.top + cardRect.height / 2;
					return mouseY < cardMiddleY ? 'before' : 'after';
				} catch (error) {
					console.error('Get drop position error:', error);
					return 'after';
				}
			}

			/**
			 * CurÄƒÈ›Äƒ toate drop targets folosind Set tracking
			 */
			clearDropTargets() {
				try {
					this.currentDropTargets.forEach(el => {
						if (el && el.classList) {
							el.classList.remove('drop-target', 'drag-over', 'drop-forbidden');
						}
					});
					this.currentDropTargets.clear();
				} catch (error) {
					console.error('Clear drop targets error:', error);
					this.currentDropTargets.clear();
				}
			}

			/**
			 * ConfigureazÄƒ event listeners pentru modal
			 */
			setupModalListeners() {
				try {
					const modal = document.getElementById('templateModal');
					const form = document.getElementById('templateForm');

					if (!modal) {
						console.warn('Template modal not found');
						return;
					}

					if (!form) {
						console.warn('Template form not found');
						return;
					}

					if (this.eventHandlers.modalMouseDown) {
						modal.removeEventListener('mousedown', this.eventHandlers.modalMouseDown);
					}
					if (this.eventHandlers.modalMouseUp) {
						modal.removeEventListener('mouseup', this.eventHandlers.modalMouseUp);
					}
					if (this.eventHandlers.modalClick) {
						modal.removeEventListener('click', this.eventHandlers.modalClick);
					}
					if (this.eventHandlers.modalKeyDown) {
						modal.removeEventListener('keydown', this.eventHandlers.modalKeyDown);
					}
					if (this.eventHandlers.formSubmit) {
						form.removeEventListener('submit', this.eventHandlers.formSubmit);
					}

					const clickState = {
						isDownOnOverlay: false,
						downTimestamp: 0,
						
						reset() {
							this.isDownOnOverlay = false;
							this.downTimestamp = 0;
						},
						
						setDown(isOnOverlay) {
							this.isDownOnOverlay = isOnOverlay;
							this.downTimestamp = Date.now();
						},
						
						isValid() {
							if (this.downTimestamp === 0) return false;
							return (Date.now() - this.downTimestamp) < 5000;
						}
					};

					this.eventHandlers.modalMouseDown = (e) => {
						const isOverlayClick = (e.target === modal);
						clickState.setDown(isOverlayClick);
					};

					this.eventHandlers.modalMouseUp = (e) => {
						try {
							const isOverlayClick = (e.target === modal);
							
							if (clickState.isDownOnOverlay && 
								isOverlayClick && 
								clickState.isValid()) {
								this.closeModal();
							}
						} catch (error) {
							console.error('Modal mouseup error:', error);
						} finally {
							clickState.reset();
						}
					};

					this.eventHandlers.modalClick = (e) => {
						try {
							const cancelBtn = e.target.closest('[data-action="cancel"]');
							if (cancelBtn) {
								clickState.reset();
								this.closeModal();
								return;
							}
						} catch (error) {
							console.error('Modal click handler error:', error);
						}
					};

					this.eventHandlers.formSubmit = async (e) => {
						try {
							e.preventDefault();
							clickState.reset();
							await this.handleFormSubmit();
						} catch (error) {
							console.error('Form submit handler error:', error);
							ToastManager.error('Failed to submit form. Please try again.');
						}
					};

					this.eventHandlers.modalKeyDown = (e) => {
						try {
							if (e.key === 'Escape') {
								clickState.reset();
								this.closeModal();
								return;
							}
							
							if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
								e.preventDefault();
								clickState.reset();
								form.requestSubmit();
							}
						} catch (error) {
							console.error('Modal keydown error:', error);
						}
					};

					modal.addEventListener('mousedown', this.eventHandlers.modalMouseDown);
					modal.addEventListener('mouseup', this.eventHandlers.modalMouseUp);
					modal.addEventListener('click', this.eventHandlers.modalClick);
					modal.addEventListener('keydown', this.eventHandlers.modalKeyDown);
					form.addEventListener('submit', this.eventHandlers.formSubmit);
					
				} catch (error) {
					console.error('Failed to setup modal listeners:', error);
				}
			}

			/**
			 * ConfigureazÄƒ file input listener pentru import JSON
			 */
			setupImportListener() {
				try {
					const importFile = document.getElementById('import-file');

					if (!importFile) {
						console.warn('Import file input not found');
						return;
					}

					if (this.eventHandlers.importChange) {
						importFile.removeEventListener('change', this.eventHandlers.importChange);
					}

					this.eventHandlers.importChange = (e) => {
						try {
							const file = e.target.files[0];
							if (!file) return;

							const reader = new FileReader();
							
							reader.onload = (loadEvent) => {
								try {
									const data = JSON.parse(loadEvent.target.result);
									this.importData(data);
								} catch (error) {
									console.error('JSON parse error:', error);
									ToastManager.error('Invalid JSON file!');
								}
							};

							reader.onerror = () => {
								console.error('File read error');
								ToastManager.error('Error reading file!');
							};

							reader.readAsText(file);
							e.target.value = '';
							
						} catch (error) {
							console.error('Import change handler error:', error);
							ToastManager.error('Import failed. Please try again.');
						}
					};

					importFile.addEventListener('change', this.eventHandlers.importChange);
					
				} catch (error) {
					console.error('Failed to setup import listener:', error);
				}
			}

			/**
			 * ConfigureazÄƒ global keyboard shortcuts
			 */
			setupKeyboardShortcuts() {
				try {
					if (this.eventHandlers.keyboardShortcuts) {
						document.removeEventListener('keydown', this.eventHandlers.keyboardShortcuts);
					}
					
					this.eventHandlers.keyboardShortcuts = (e) => {
						try {
							if (e.target.matches('input, textarea, select')) {
								if (e.key === 'Escape') {
									this.closeModal();
								}
								return;
							}

							if (e.key === 'Escape') {
								if (this.draggedTemplate) {
									e.preventDefault();
									
									try {
										if (!this.draggedTemplate) {
											return;
										}
										
										const draggedCard = document.querySelector(`[data-template-id="${this.draggedTemplate}"]`);
										if (draggedCard) {
											draggedCard.classList.remove('dragging');
										}
										
										this.clearDropTargets();
										
										this.draggedTemplate = null;
										document.body.classList.remove('is-dragging');
										
										console.log('Drag operation cancelled by Escape');
									} catch (error) {
										console.error('Error cancelling drag operation:', error);
										
										this.draggedTemplate = null;
										document.body.classList.remove('is-dragging');
										
										if (this.currentDropTargets) {
											this.currentDropTargets.clear();
										} else {
											this.currentDropTargets = new Set();
										}
									}
									return;
								}
								
								if (DialogManager.activeDialog) {
									return;
								}
								
								this.closeModal();
								return;
							}

							if (e.ctrlKey || e.metaKey) {
								switch (e.key.toLowerCase()) {
									case 'n':
										e.preventDefault();
										const modal = document.getElementById('templateModal');
										if (modal && modal.classList.contains('show')) {
											console.log('Modal already open');
											return;
										}
										this.openModal();
										break;
										
									case 's':
										e.preventDefault();
										this.exportData();
										break;
										
									case 'f':
										e.preventDefault();
										const searchBar = document.getElementById('searchBar');
										if (searchBar) {
											searchBar.focus();
											searchBar.select();
										} else {
											console.warn('Search bar not found for Ctrl+F shortcut');
										}
										break;
								}
							}
							
						} catch (error) {
							console.error('Keyboard shortcut handler error:', error);
						}
					};

					document.addEventListener('keydown', this.eventHandlers.keyboardShortcuts);
					
				} catch (error) {
					console.error('Failed to setup keyboard shortcuts:', error);
				}
			}

			/* ========================================================================
			   ğŸ“ TEMPLATE MANAGEMENT
			   ======================================================================== */

			/**
			 * AdaugÄƒ un template nou
			 * @param {Object} templateData
			 */
			async addTemplate(templateData) {
				try {
					if (!templateData || typeof templateData !== 'object') {
						console.error('Invalid template data:', templateData);
						ToastManager.error('Invalid template data provided!');
						return false;
					}
					
					if (!templateData.name || !templateData.category || !templateData.content) {
						console.error('Missing required fields in template data');
						ToastManager.error('Please fill in all required fields: name, category, and content');
						return false;
					}
					
					const newTemplate = {
						id: Utils.generateId(),
						name: Utils.sanitizeString(templateData.name, 200),
						category: String(templateData.category).trim(),
						content: Utils.sanitizeString(templateData.content, 5000),
						tags: Array.isArray(templateData.tags) 
							? templateData.tags
								.filter(tag => typeof tag === 'string' && tag.trim())
								.map(tag => Utils.sanitizeString(tag.trim(), 50))
								.slice(0, 3)
							: [],
						createdAt: new Date().toISOString(),
						active: true,
						order: this.getNextOrder(templateData.category)
					};

					this.templates.push(newTemplate);
					
					const saveResult = await this.saveData();
					
					if (saveResult.success) {
						this.renderUI({ 
							templates: true, 
							categoryCounts: true, 
							stats: true 
						});
						
						const category = this.categories.find(c => c.id === newTemplate.category);
						const categoryName = category?.name || 'Unknown Category';
						const categoryEmoji = category?.emoji || 'ğŸ“';
						
						ToastManager.success(
							`âœ¨ "${newTemplate.name}" added to ${categoryEmoji} ${categoryName}!`
						);
						return true;
					} else {
						this.templates = this.templates.filter(t => t.id !== newTemplate.id);
						
						ToastManager.error(
							saveResult.message || 
							`Failed to save "${newTemplate.name}". Please try again.`
						);
						return false;
					}
					
				} catch (error) {
					console.error('Add template error:', error);
					
					const templateName = templateData?.name ? `"${templateData.name}"` : 'template';
					ToastManager.error(
						`Failed to add ${templateName}. ${error.message || 'Please try again.'}`
					);
					return false;
				}
			}

			/**
			 * UpdateazÄƒ un template existent
			 * @param {string} id
			 * @param {Object} updates
			 */
			async updateTemplate(id, updates) {
				try {
					if (!id) {
						console.error('Template ID is required');
						return false;
					}
					
					if (!updates || typeof updates !== 'object') {
						console.error('Invalid updates object:', updates);
						return false;
					}
					
					const index = this.templates.findIndex(t => t.id === id);
					if (index === -1) {
						console.warn(`Template not found: ${id}`);
						ToastManager.error(
							'Template not found. It may have been deleted in another tab.'
						);
						return false;
					}

					const backup = { ...this.templates[index] };
					const categoryChanged = updates.category && updates.category !== backup.category;

					const sanitizedUpdates = {};
					
					if (updates.name !== undefined) {
						sanitizedUpdates.name = Utils.sanitizeString(updates.name, 200);
					}
					
					if (updates.category !== undefined) {
						sanitizedUpdates.category = String(updates.category).trim();
						
						if (categoryChanged) {
							sanitizedUpdates.order = this.getNextOrder(sanitizedUpdates.category);
						}
					}
					
					if (updates.content !== undefined) {
						sanitizedUpdates.content = Utils.sanitizeString(updates.content, 5000);
					}
					
					if (updates.tags !== undefined) {
						sanitizedUpdates.tags = Array.isArray(updates.tags)
							? updates.tags
								.filter(tag => typeof tag === 'string' && tag.trim())
								.map(tag => Utils.sanitizeString(tag.trim(), 50))
								.slice(0, 3)
							: [];
					}
					
					if (updates.order !== undefined && !categoryChanged) {
						sanitizedUpdates.order = typeof updates.order === 'number' ? updates.order : 0;
					}

					this.templates[index] = { 
						...this.templates[index], 
						...sanitizedUpdates
					};

					const saveResult = await this.saveData();
					
					if (saveResult.success) {
						if (categoryChanged) {
							this.renderUI({ 
								templates: true, 
								categoryCounts: true, 
								stats: true 
							});
						} else {
							this.renderUI({ 
								templateCard: id, 
								stats: true 
							});
						}
						
						const templateName = this.templates[index].name;
						
						if (categoryChanged) {
							const oldCat = this.categories.find(c => c.id === backup.category);
							const newCat = this.categories.find(c => c.id === sanitizedUpdates.category);
							
							ToastManager.success(
								`ğŸ“¦ "${templateName}" moved from ${oldCat?.emoji || 'ğŸ“'} ${oldCat?.name || 'Unknown'} to ${newCat?.emoji || 'ğŸ“'} ${newCat?.name || 'Unknown'}`
							);
						} else if (updates.name && updates.name !== backup.name) {
							ToastManager.success(
								`âœï¸ Template renamed to "${templateName}"`
							);
						} else if (updates.content !== undefined) {
							ToastManager.success(
								`ğŸ’¾ "${templateName}" updated successfully`
							);
						} else if (updates.tags !== undefined) {
							const tagCount = this.templates[index].tags?.length || 0;
							ToastManager.success(
								`ğŸ·ï¸ "${templateName}" tags updated (${tagCount} tag${tagCount !== 1 ? 's' : ''})`
							);
						} else {
							ToastManager.success(
								`âœ… "${templateName}" updated successfully`
							);
						}
						
						return true;
					} else {
						this.templates[index] = backup;
						
						ToastManager.error(
							saveResult.message || 
							`Failed to save changes to "${backup.name}". Please try again.`
						);
						return false;
					}
					
				} catch (error) {
					console.error('Update template error:', error);
					
					const templateName = this.templates.find(t => t.id === id)?.name;
					ToastManager.error(
						`Failed to update ${templateName ? `"${templateName}"` : 'template'}. ${error.message || 'Please try again.'}`
					);
					return false;
				}
			}

			/**
			 * È˜terge un template dupÄƒ confirmare
			 * @param {string} id
			 */
			async deleteTemplate(id) {
				let backup = null;
				
				try {
					if (!id) {
						console.error('Template ID is required');
						return;
					}
					
					const template = this.templates.find(t => t.id === id);
					if (!template) {
						console.warn(`Template not found: ${id}`);
						ToastManager.warning('Template not found. It may have already been deleted.');
						return;
					}

					const category = this.categories.find(c => c.id === template.category);
					const categoryInfo = category ? `${category.emoji} ${category.name}` : 'Unknown Category';
					
					const confirmed = await DialogManager.confirm({
						title: 'Delete Template',
						message: `Are you sure you want to delete "${Utils.escapeHtml(template.name)}"?\n
							Category: ${categoryInfo}
							${template.tags?.length > 0 ? `Tags: ${template.tags.join(', ')}` : ''}`,
						confirmText: 'Delete',
						cancelText: 'Cancel',
						type: 'danger'
					});

					if (!confirmed) return;

					backup = [...this.templates];
					const affectedCategory = template.category;
					const templateName = template.name;
					
					this.templates = this.templates.filter(t => t.id !== id);
					
					this.reorderCategoryTemplates(affectedCategory);
					
					const saveResult = await this.saveData();
					
					if (saveResult.success) {
						const card = document.querySelector(`[data-template-id="${id}"]`);
						if (card) {
							card.classList.add('template-exit');
							card.style.pointerEvents = 'none';
							
							setTimeout(() => {
								this.renderUI({ 
									templates: true, 
									categoryCounts: true, 
									stats: true 
								});
							}, 200);
						} else {
							this.renderUI({ 
								templates: true, 
								categoryCounts: true, 
								stats: true 
							});
						}
						
						const remainingCount = this.templates.filter(t => t.category === affectedCategory).length;
						ToastManager.success(
							`ğŸ—‘ï¸ "${templateName}" deleted successfully (${remainingCount} remaining in ${categoryInfo})`
						);
					} else {
						if (backup) {
							this.templates = backup;
						}
						
						ToastManager.error(
							saveResult.message || 
							`Failed to delete "${templateName}". Please try again.`
						);
					}
					
				} catch (error) {
					console.error('Delete template error:', error);
					
					if (backup && backup.length > 0) {
						this.templates = backup;
						this.renderUI({ templates: true });
					}
					
					const template = backup?.find(t => t.id === id);
					ToastManager.error(
						`Failed to delete ${template?.name ? `"${template.name}"` : 'template'}. ${error.message || 'Please try again.'}`
					);
				}
			}
			
			/**
			 * ReordoneazÄƒ templates pentru o categorie (eliminÄƒ gap-uri)
			 * @param {string} categoryId
			 */
			reorderCategoryTemplates(categoryId) {
				if (!categoryId) return;
				
				const categoryTemplates = this.templates
					.filter(t => t.category === categoryId)
					.sort((a, b) => (a.order || 0) - (b.order || 0));
				
				categoryTemplates.forEach((template, index) => {
					const t = this.templates.find(temp => temp.id === template.id);
					if (t) t.order = index;
				});
			}
			
			/**
			 * AfiÈ™eazÄƒ empty state cÃ¢nd nu sunt templates
			 * Context-aware cu action buttons È™i detalii extinse
			 */
			showEmptyState() {
				try {
					const grid = document.getElementById('templatesGrid');
					if (!grid) return;
					
					const existingEmptyState = grid.querySelector('.empty-state');
					if (existingEmptyState) {
						existingEmptyState.remove();
					}
					
					const hasSearch = this.searchTerm && this.searchTerm.trim();
					const hasTemplates = this.templates && this.templates.length > 0;
					const isAllCategories = this.activeCategory === 'toate';
					
					let icon, title, message, buttonsHTML = '';
					
					if (hasSearch) {
						icon = 'ğŸ”';
						title = 'No results found';
						
						if (!isAllCategories) {
							const category = this.categories.find(c => c.id === this.activeCategory);
							const categoryName = Utils.escapeHtml(category?.name || 'this category');
							const categoryEmoji = Utils.escapeHtml(category?.emoji || 'ğŸ“');
							
							const templatesInCategory = this.templates.filter(t => t.category === this.activeCategory);
							const totalInCategory = templatesInCategory.length;
							
							const searchLower = this.searchTerm.toLowerCase().trim();
							const allResults = this.templates.filter(t => {
								const nameMatch = t.name?.toLowerCase().includes(searchLower);
								const contentMatch = t.content?.toLowerCase().includes(searchLower);
								const tagsMatch = t.tags?.some(tag => tag.toLowerCase().includes(searchLower));
								return nameMatch || contentMatch || tagsMatch;
							});
							
							const resultsInOtherCategories = allResults.length;
							
							message = `No templates match <strong>"${Utils.escapeHtml(this.searchTerm)}"</strong> in ${categoryEmoji} <strong>${categoryName}</strong>`;
							
							if (totalInCategory > 0) {
								message += `<br><br>ğŸ“Š Searched <strong>${totalInCategory}</strong> template${totalInCategory !== 1 ? 's' : ''} in this category`;
							} else {
								message += `<br><br>â„¹ï¸ This category is currently empty`;
							}
							
							if (resultsInOtherCategories > 0) {
								message += `<br><br>ğŸ’¡ Found <strong>${resultsInOtherCategories}</strong> matching template${resultsInOtherCategories !== 1 ? 's' : ''} in other categories`;
								
								const resultsByCategory = {};
								allResults.forEach(t => {
									resultsByCategory[t.category] = (resultsByCategory[t.category] || 0) + 1;
								});
								
								const topResultCategories = Object.entries(resultsByCategory)
									.sort((a, b) => b[1] - a[1])
									.slice(0, 3)
									.map(([catId, count]) => {
										const cat = this.categories.find(c => c.id === catId);
										return `${cat?.emoji || 'ğŸ“'} ${cat?.name || catId} (${count})`;
									})
									.join(', ');
								
								if (topResultCategories) {
									message += `<br>ğŸ“‚ <em>In: ${topResultCategories}</em>`;
								}
							} else {
								message += `<br><br>ğŸ’­ <em>No templates match this search across all ${this.templates.length} template${this.templates.length !== 1 ? 's' : ''}</em>`;
								message += `<br>ğŸ’¡ Try different keywords or create a new template`;
							}
							
							buttonsHTML = `
								<div class="empty-state-actions">
									<button type="button" class="btn btn-secondary" data-empty-action="clear-search">
										<span aria-hidden="true">âœ•</span>
										<span>Clear Search</span>
									</button>
									${resultsInOtherCategories > 0 ? `
										<button type="button" class="btn btn-primary" data-empty-action="search-all">
											<span aria-hidden="true">ğŸ”</span>
											<span>View All Results (${resultsInOtherCategories})</span>
										</button>
									` : `
										<button type="button" class="btn btn-primary" data-empty-action="create-template">
											<span aria-hidden="true">â•</span>
											<span>Create "${Utils.escapeHtml(this.searchTerm.substring(0, 20))}"</span>
										</button>
									`}
								</div>
							`;
						} else {
							const totalTemplates = this.templates.length;
							
							message = `No templates match <strong>"${Utils.escapeHtml(this.searchTerm)}"</strong>`;
							
							if (totalTemplates > 0) {
								message += `<br><br>ğŸ“Š Searched across <strong>${totalTemplates}</strong> template${totalTemplates !== 1 ? 's' : ''} in all categories`;
								
								const categoriesWithTemplates = this.categories
									.filter(c => c.id !== 'toate')
									.map(c => {
										const count = this.templates.filter(t => t.category === c.id).length;
										return { ...c, count };
									})
									.filter(c => c.count > 0)
									.sort((a, b) => b.count - a.count)
									.slice(0, 3);
								
								if (categoriesWithTemplates.length > 0) {
									const catList = categoriesWithTemplates
										.map(c => `${c.emoji} ${c.name} (${c.count})`)
										.join(', ');
									message += `<br><br>ğŸ’¡ <em>Try browsing by category: ${catList}</em>`;
								} else {
									message += `<br><br>ğŸ’­ <em>Try different keywords or check for typos</em>`;
								}
							} else {
								message += `<br><br>ğŸ“‹ <em>No templates exist yet. Create your first one!</em>`;
							}
							
							buttonsHTML = `
								<div class="empty-state-actions">
									<button type="button" class="btn btn-secondary" data-empty-action="clear-search">
										<span aria-hidden="true">âœ•</span>
										<span>Clear Search</span>
									</button>
									<button type="button" class="btn btn-primary" data-empty-action="create-template">
										<span aria-hidden="true">â•</span>
										<span>Create Template</span>
									</button>
								</div>
							`;
						}
					}
					else if (!hasTemplates) {
						icon = 'ğŸ“‹';
						title = 'No templates yet';
						message = `
							<strong>Welcome to Templates Manager!</strong>
							<br><br>
							Get started by creating your first template to save time and boost productivity.
							<br><br>
							ğŸ’¡ <em>Templates are reusable text snippets that help you work faster</em>
						`;
						buttonsHTML = `
							<div class="empty-state-actions">
								<button type="button" class="btn btn-primary" data-empty-action="create-template">
									<span aria-hidden="true">â•</span>
									<span>Create Your First Template</span>
								</button>
							</div>
						`;
					}
					else if (!isAllCategories) {
						const category = this.categories.find(c => c.id === this.activeCategory);
						const categoryName = category?.name || 'this category';
						const categoryEmoji = category?.emoji || 'ğŸ“';
						
						icon = categoryEmoji;
						title = `No templates in "${categoryName}"`;
						
						const totalTemplates = this.templates.length;
						
						if (totalTemplates > 0) {
							message = `
								<strong>This category is currently empty</strong>
								<br><br>
								ğŸ“Š You have <strong>${totalTemplates}</strong> template${totalTemplates !== 1 ? 's' : ''} in other categories
							`;
							
							const templatesByCategory = {};
							this.templates.forEach(t => {
								templatesByCategory[t.category] = (templatesByCategory[t.category] || 0) + 1;
							});
							
							const topCategories = Object.entries(templatesByCategory)
								.sort((a, b) => b[1] - a[1])
								.slice(0, 3)
								.map(([catId, count]) => {
									const cat = this.categories.find(c => c.id === catId);
									return { 
										name: cat?.name || catId, 
										emoji: cat?.emoji || 'ğŸ“', 
										count 
									};
								});
							
							if (topCategories.length > 0) {
								const topList = topCategories
									.map(c => `${c.emoji} ${c.name} (${c.count})`)
									.join(', ');
								message += `<br><br>ğŸ“‚ <em>Most used: ${topList}</em>`;
							}
							
							message += `<br><br>ğŸ’¡ Add a template here or view all templates`;
							
							buttonsHTML = `
								<div class="empty-state-actions">
									<button type="button" class="btn btn-primary" data-empty-action="add-template">
										<span aria-hidden="true">â•</span>
										<span>Add to ${categoryEmoji} ${categoryName}</span>
									</button>
									<button type="button" class="btn btn-secondary" data-empty-action="view-all">
										<span aria-hidden="true">ğŸ“</span>
										<span>View All Templates (${totalTemplates})</span>
									</button>
								</div>
							`;
						} else {
							message = `
								<strong>Start organizing your templates!</strong>
								<br><br>
								Create your first template in the "${categoryName}" category
								<br><br>
								ğŸ’¡ <em>Organize templates by category to find them faster later</em>
							`;
							
							buttonsHTML = `
								<div class="empty-state-actions">
									<button type="button" class="btn btn-primary" data-empty-action="add-template">
										<span aria-hidden="true">â•</span>
										<span>Create in ${categoryEmoji} ${categoryName}</span>
									</button>
								</div>
							`;
						}
					} else {
						icon = 'ğŸ“‹';
						title = 'No templates found';
						message = `
							<strong>No templates to display</strong>
							<br><br>
							Add your first template to get started
							<br><br>
							ğŸ’¡ <em>Templates help you save time by reusing common text</em>
						`;
						buttonsHTML = `
							<div class="empty-state-actions">
								<button type="button" class="btn btn-primary" data-empty-action="create-template">
									<span aria-hidden="true">â•</span>
									<span>Create Template</span>
								</button>
							</div>
						`;
					}
					
					const emptyState = document.createElement('div');
					emptyState.className = 'empty-state';
					emptyState.innerHTML = `
						<h3><span aria-hidden="true">${icon}</span> ${title}</h3>
						<p>${message}</p>
						${buttonsHTML}
					`;
					
					grid.appendChild(emptyState);
				} catch (error) {
					console.error('Show empty state error:', error);
				}
			}

			/**
			 * Deschide modal pentru editare template
			 * @param {string} id
			 */
			async editTemplate(id) {
				try {
					if (!id) {
						console.error('Template ID is required');
						return;
					}
					
					if (this.editingTemplate && this.editingTemplate.id !== id) {
						const currentTemplateName = this.editingTemplate.name || 'Untitled';
						const newTemplate = this.templates.find(t => t.id === id);
						const newTemplateName = newTemplate?.name || 'Unknown';
						
						const confirmed = await DialogManager.confirm({
							title: 'Unsaved Changes',
							message: `You have unsaved changes in "${Utils.escapeHtml(currentTemplateName)}".\n
								Do you want to discard them and edit "${Utils.escapeHtml(newTemplateName)}"?`,
							confirmText: 'Discard & Continue',
							cancelText: 'Keep Editing',
							type: 'warning'
						});
						
						if (!confirmed) return;
					}
					
					const template = this.templates.find(t => t.id === id);
					if (!template) {
						console.warn(`Template not found: ${id}`);
						
						ToastManager.warning(
							'Template not found. It may have been deleted in another tab. Refreshing...'
						);
						
						await this.loadData(false);
						this.renderUI({ templates: true });
						return;
					}

					this.editingTemplate = template;
					this.openModal(template);
					
				} catch (error) {
					console.error('Edit template error:', error);
					
					const template = this.templates.find(t => t.id === id);
					ToastManager.error(
						`Failed to open editor for ${template?.name ? `"${template.name}"` : 'template'}. ${error.message || 'Please try again.'}`
					);
				}
			}

			/**
			 * CopiazÄƒ conÈ›inutul template-ului Ã®n clipboard
			 * @param {string} id - ID-ul template-ului
			 */
			async copyTemplateContent(id) {
				try {
					if (!id) {
						console.error('Template ID is required');
						return;
					}
					
					const template = this.templates.find(t => t?.id === id);
					if (!template) {
						console.warn(`Template not found: ${id}`);
						
						ToastManager.warning(
							'Template not found. It may have been deleted. Please refresh the page.'
						);
						return;
					}

					if (!template.content) {
						console.warn(`Template ${id} has no content`);
						
						ToastManager.warning(
							`"${template.name}" is empty - nothing to copy!`
						);
						return;
					}

					if (navigator.clipboard && navigator.clipboard.writeText) {
						try {
							await navigator.clipboard.writeText(template.content);
							
							const contentLength = template.content.length;
							const lengthInfo = contentLength > 100 
								? `${contentLength} characters` 
								: `${contentLength} char${contentLength !== 1 ? 's' : ''}`;
							
							ToastManager.success(
								`ğŸ“‹ "${template.name}" copied to clipboard! (${lengthInfo})`
							);
							return;
						} catch (clipboardError) {
							console.warn('Clipboard API failed, trying fallback:', clipboardError);
						}
					}
					
					const textarea = document.createElement('textarea');
					textarea.value = template.content;
					textarea.style.position = 'fixed';
					textarea.style.left = '-999999px';
					textarea.style.top = '-999999px';
					document.body.appendChild(textarea);
					textarea.focus();
					textarea.select();
					
					try {
						const successful = document.execCommand('copy');
						if (successful) {
							const contentLength = template.content.length;
							ToastManager.success(
								`ğŸ“‹ "${template.name}" copied! (${contentLength} characters)`
							);
						} else {
							throw new Error('execCommand failed');
						}
					} catch (execError) {
						console.error('Fallback copy failed:', execError);
						
						ToastManager.error(
							`Failed to copy "${template.name}". Please select and copy manually (Ctrl+C).`
						);
					} finally {
						document.body.removeChild(textarea);
					}
					
				} catch (error) {
					console.error('Copy template content error:', error);
					
					const template = this.templates.find(t => t?.id === id);
					ToastManager.error(
						`Failed to copy ${template?.name ? `"${template.name}"` : 'template'}. ${error.message || 'Please try again.'}`
					);
				}
			}

			/**
			 * CalculeazÄƒ urmÄƒtorul order pentru o categorie
			 * @param {string} categoryId - ID-ul categoriei
			 * @returns {number} UrmÄƒtorul numÄƒr de ordine disponibil
			 */
			getNextOrder(categoryId) {
				try {
					if (!categoryId) {
						console.warn('Category ID is required for getNextOrder');
						return 0;
					}
					
					if (!Array.isArray(this.templates)) {
						console.error('Templates array is invalid');
						return 0;
					}
					
					const categoryTemplates = this.templates.filter(t => t.category === categoryId);
					
					if (categoryTemplates.length === 0) {
						return 0;
					}
					
					const existingOrders = new Set(
						categoryTemplates
							.map(t => t.order)
							.filter(order => typeof order === 'number' && !isNaN(order) && isFinite(order))
					);
					
					let nextOrder = 0;
					while (existingOrders.has(nextOrder)) {
						nextOrder++;
					}
					
					return nextOrder;
					
				} catch (error) {
					console.error('Get next order error:', error);
					return 0;
				}
			}

			/**
			 * MutÄƒ un template Ã®ntr-o altÄƒ categorie
			 * @param {string} templateId
			 * @param {string} categoryId
			 */
			async moveTemplateToCategory(templateId, categoryId) {
				try {
					if (!templateId || !categoryId) {
						console.error('Template ID and Category ID are required');
						ToastManager.error('Cannot move template: Missing template or category ID');
						return false;
					}
					
					const template = this.templates.find(t => t.id === templateId);
					if (!template) {
						console.warn(`Template not found: ${templateId}`);
						
						ToastManager.warning(
							'Template not found. It may have been deleted. Please refresh the page.'
						);
						return false;
					}
					
					const category = this.categories.find(c => c.id === categoryId);
					if (!category) {
						console.warn(`Category not found: ${categoryId}`);
						
						ToastManager.error(
							`Target category not found. Cannot move "${template.name}".`
						);
						return false;
					}
					
					if (template.category === categoryId) {
						console.log('Template already in target category');
						
						ToastManager.info(
							`"${template.name}" is already in ${category.emoji} ${category.name}`
						);
						return true;
					}
					
					const oldCategory = template.category;
					
					const success = await this.updateTemplate(templateId, {
						category: categoryId,
						order: this.getNextOrder(categoryId)
					});
					
					if (success) {
						this.reorderCategoryTemplates(oldCategory);
						
						await this.saveData();
						this.renderUI({ 
							templates: true, 
							categoryCounts: true, 
							stats: true 
						});
					}
					
					return success;
					
				} catch (error) {
					console.error('Move template to category error:', error);
					
					const template = this.templates.find(t => t.id === templateId);
					const category = this.categories.find(c => c.id === categoryId);
					
					ToastManager.error(
						`Failed to move ${template?.name ? `"${template.name}"` : 'template'} to ${category?.name || 'category'}. ${error.message || 'Please try again.'}`
					);
					return false;
				}
			}

			/**
			 * ReordoneazÄƒ templates prin drag & drop
			 * @param {string} draggedId - ID-ul template-ului tras
			 * @param {string} targetId - ID-ul template-ului È›intÄƒ
			 * @param {string} position - PoziÈ›ia relativÄƒ: "before" sau "after"
			 */
			async reorderTemplates(draggedId, targetId, position) {
				try {
					if (!draggedId || !targetId) {
						console.error('Dragged ID and Target ID are required');
						ToastManager.error('Cannot reorder: Missing template IDs');
						return;
					}
					
					if (draggedId === targetId) {
						console.log('Cannot reorder template over itself');
						return;
					}
					
					if (position !== 'before' && position !== 'after') {
						console.error('Position must be "before" or "after"');
						ToastManager.error('Invalid reorder position');
						return;
					}
					
					const templatesSnapshot = [...this.templates];
					
					const draggedTemplate = templatesSnapshot.find(t => t.id === draggedId);
					const targetTemplate = templatesSnapshot.find(t => t.id === targetId);

					if (!draggedTemplate || !targetTemplate) {
						console.warn('Dragged or target template not found - likely deleted in another tab');
						
						ToastManager.warning(
							'Template no longer exists. Reloading templates...', 
							4000
						);
						
						await this.loadData(false);
						this.renderUI({ templates: true });
						
						return;
					}

					if (draggedTemplate.category !== targetTemplate.category) {
						console.log('Cannot reorder templates from different categories');
						
						const draggedCat = this.categories.find(c => c.id === draggedTemplate.category);
						const targetCat = this.categories.find(c => c.id === targetTemplate.category);
						
						ToastManager.info(
							`Cannot reorder between categories (${draggedCat?.name || 'Unknown'} â‰  ${targetCat?.name || 'Unknown'})`
						);
						return;
					}

					const backup = {
						templates: JSON.parse(JSON.stringify(this.templates)),
						timestamp: Date.now()
					};

					let categoryTemplates = templatesSnapshot
						.filter(t => t.category === draggedTemplate.category)
						.sort((a, b) => (a.order || 0) - (b.order || 0))
						.map(t => ({ ...t }));

					const draggedIndex = categoryTemplates.findIndex(t => t.id === draggedId);
					
					if (draggedIndex === -1) {
						console.error('Dragged template not found in category after filter');
						
						await this.loadData(false);
						this.renderUI({ templates: true });
						
						ToastManager.error('Reorder failed: Template not found in category. Reloading...');
						return;
					}
					
					categoryTemplates.splice(draggedIndex, 1);

					const targetIndex = categoryTemplates.findIndex(t => t.id === targetId);
					
					if (targetIndex === -1) {
						console.error('Target template not found in category after removal');
						
						this.templates = backup.templates;
						this.renderUI({ templates: true });
						
						ToastManager.error('Reorder failed: Target template not found. Changes reverted.');
						return;
					}
					
					const insertIndex = position === 'before' ? targetIndex : targetIndex + 1;
					categoryTemplates.splice(insertIndex, 0, draggedTemplate);
					
					categoryTemplates = categoryTemplates.map((template, index) => ({
						...template,
						order: index
					}));

					this.templates = this.templates.map(t => {
						const reordered = categoryTemplates.find(ct => ct.id === t.id);
						return reordered ? { ...reordered } : t;
					});

					const saveResult = await this.saveData();
					
					if (saveResult.success) {
						this.renderUI({ 
							templates: true, 
							stats: true 
						});
						
						const category = this.categories.find(c => c.id === draggedTemplate.category);
						const newPosition = categoryTemplates.findIndex(t => t.id === draggedId) + 1;
						const totalInCategory = categoryTemplates.length;
						
						ToastManager.success(
							`â†•ï¸ "${draggedTemplate.name}" moved to position ${newPosition}/${totalInCategory} in ${category?.emoji || 'ğŸ“'} ${category?.name || 'category'}`
						);
					} else {
						this.templates = backup.templates;
						this.renderUI({ templates: true });
						
						ToastManager.error(
							saveResult.message || 
							`Failed to reorder "${draggedTemplate.name}". Changes reverted.`
						);
					}
					
				} catch (error) {
					console.error('Reorder templates error:', error);
					
					await this.loadData(false);
					this.renderUI({ templates: true });
					
					const draggedTemplate = this.templates.find(t => t.id === draggedId);
					ToastManager.error(
						`Failed to reorder ${draggedTemplate?.name ? `"${draggedTemplate.name}"` : 'template'}. ${error.message || 'Data reloaded.'}`
					);
				}
			}

			/* ========================================================================
			   ğŸ·ï¸ CATEGORY MANAGEMENT
			   ======================================================================== */

			/**
			 * Dialog pentru adÄƒugare categorie nouÄƒ
			 */
			async addNewCategory() {
				try {
					const name = await DialogManager.prompt({
						title: 'New Category',
						message: 'Enter category name:',
						placeholder: 'e.g., Quick Replies',
						confirmText: 'Add',
						cancelText: 'Cancel'
					});

					if (!name || !name.trim()) {
						return false;
					}

					const trimmedName = name.trim();
					
					return await this.addCategory(trimmedName);
					
				} catch (error) {
					console.error('Add new category error:', error);
					ToastManager.error(
						`Failed to create new category. ${error.message || 'Please try again.'}`
					);
					return false;
				}
			}

			/**
			 * AdaugÄƒ categorie nouÄƒ cu validare
			 * @param {string} name
			 * @returns {Promise<boolean>}
			 */
			async addCategory(name) {
				let categoryAdded = false;
				let newCategory = null;
				
				try {
					if (!name || typeof name !== 'string') {
						console.error('Invalid category name:', name);
						ToastManager.error('Invalid category name provided!');
						return false;
					}

					const sanitizedName = Utils.sanitizeString(name, 100);

					if (!sanitizedName || sanitizedName.length < 2) {
						ToastManager.error(
							`Category name too short!\n\n` +
							`Please enter at least 2 characters (you entered ${sanitizedName?.length || 0}).`
						);
						return false;
					}

					const duplicate = this.categories.find(c => 
						c.name.toLowerCase() === sanitizedName.toLowerCase()
					);

					if (duplicate) {
						ToastManager.error(
							`Category "${sanitizedName}" already exists!\n\n` +
							`ğŸ’¡ Try a different name or use the existing category ${duplicate.emoji}.`
						);
						return false;
					}

					newCategory = {
						id: Utils.generateId('cat_'),
						name: sanitizedName,
						emoji: Array.isArray(this.categoryEmojis) && this.categoryEmojis.length > 0
							? this.categoryEmojis[Math.floor(Math.random() * this.categoryEmojis.length)]
							: 'ğŸ“',
						color: Array.isArray(this.categoryColors) && this.categoryColors.length > 0
							? this.categoryColors[Math.floor(Math.random() * this.categoryColors.length)]
							: '#6366f1'
					};

					this.categories.push(newCategory);
					categoryAdded = true;
					
					const saveResult = await this.saveData();
					
					if (saveResult.success) {
						this.renderUI({ 
							categories: true, 
							stats: true 
						});
						
						const totalCategories = this.categories.filter(c => c.id !== 'toate').length;
						
						ToastManager.success(
							`âœ¨ Category "${newCategory.name}" created with ${newCategory.emoji}!\n\n` +
							`ğŸ“Š You now have ${totalCategories} categor${totalCategories !== 1 ? 'ies' : 'y'}.`
						);
						return true;
					} else {
						this.categories = this.categories.filter(c => c.id !== newCategory.id);
						
						ToastManager.error(
							saveResult.message || 
							`Failed to save category "${newCategory.name}".\n\n` +
							`ğŸ’¡ Please try again or check your storage space.`
						);
						return false;
					}
					
				} catch (error) {
					console.error('Add category error:', error);
					
					if (categoryAdded && newCategory) {
						this.categories = this.categories.filter(c => c.id !== newCategory.id);
						console.log('Rolled back category addition due to error');
					}
					
					const categoryName = newCategory?.name || 'new category';
					ToastManager.error(
						`Failed to add "${categoryName}".\n\n` +
						`Error: ${error.message || 'Unknown error occurred'}\n\n` +
						`ğŸ’¡ Please try again or refresh the page.`
					);
					return false;
				}
			}

			/**
			 * EditeazÄƒ numele unei categorii
			 * @param {string} categoryId
			 * @returns {Promise<boolean>}
			 */
			async editCategory(categoryId) {
				let backup = null;
				let categoryIndex = -1;
				let categoryModified = false;
				
				try {
					if (!categoryId) {
						console.error('Category ID is required');
						ToastManager.error('Cannot edit category: ID is missing!');
						return false;
					}
					
					if (categoryId === 'toate') {
						ToastManager.error(
							`Cannot rename "All Categories"!\n\n` +
							`This is a special category that shows all your templates.`
						);
						return false;
					}
					
					categoryIndex = this.categories.findIndex(c => c.id === categoryId);
					
					if (categoryIndex === -1) {
						console.warn('Category not found:', categoryId);
						ToastManager.warning(
							`Category not found!\n\n` +
							`It may have been deleted in another tab. Please refresh the page.`
						);
						return false;
					}

					const category = this.categories[categoryIndex];
					backup = { ...category };
					
					const templatesInCategory = this.templates.filter(t => t.category === categoryId).length;
					
					const newName = await DialogManager.prompt({
						title: `Edit Category ${category.emoji}`,
						message: templatesInCategory > 0
							? `Rename category (${templatesInCategory} template${templatesInCategory !== 1 ? 's' : ''}):`
							: 'Enter new category name:',
						defaultValue: category.name,
						confirmText: 'Save',
						cancelText: 'Cancel'
					});

					if (!newName || !newName.trim()) {
						return false;
					}

					const trimmedName = newName.trim();

					if (trimmedName.toLowerCase() === category.name.toLowerCase()) {
						ToastManager.info(
							`No changes made.\n\n` +
							`Category "${category.name}" ${category.emoji} remains unchanged.`
						);
						return false;
					}

					const sanitizedName = Utils.sanitizeString(trimmedName, 100);

					if (!sanitizedName || sanitizedName.length < 2) {
						ToastManager.error(
							`Category name too short!\n\n` +
							`Please enter at least 2 characters (you entered ${sanitizedName?.length || 0}).`
						);
						return false;
					}

					const duplicate = this.categories.find(c => 
						c.id !== categoryId && 
						c.name.toLowerCase() === sanitizedName.toLowerCase()
					);

					if (duplicate) {
						ToastManager.error(
							`Category "${sanitizedName}" already exists!\n\n` +
							`Existing category: ${duplicate.emoji} "${duplicate.name}"\n\n` +
							`ğŸ’¡ Please choose a different name.`
						);
						return false;
					}
					
					const oldName = category.name;
					
					this.categories[categoryIndex] = {
						...category,
						name: sanitizedName
					};
					categoryModified = true;
					
					const saveResult = await this.saveData();
					
					if (saveResult.success) {
						this.renderUI({ 
							categories: true, 
							templates: true 
						});
						
						const message = templatesInCategory > 0
							? `âœï¸ Category renamed!\n\n` +
							  `"${oldName}" â†’ "${sanitizedName}" ${category.emoji}\n\n` +
							  `ğŸ“‹ ${templatesInCategory} template${templatesInCategory !== 1 ? 's' : ''} updated.`
							: `âœï¸ Category renamed from "${oldName}" to "${sanitizedName}" ${category.emoji}`;
						
						ToastManager.success(message);
						return true;
					} else {
						this.categories[categoryIndex] = backup;
						
						ToastManager.error(
							saveResult.message || 
							`Failed to rename category "${oldName}".\n\n` +
							`ğŸ’¡ Please try again or check your storage space.`
						);
						return false;
					}
					
				} catch (error) {
					console.error('Edit category error:', error);
					
					if (categoryModified && backup && categoryIndex !== -1) {
						this.categories[categoryIndex] = backup;
						console.log('Rolled back category edit due to error');
					}
					
					const categoryName = backup?.name || 'category';
					ToastManager.error(
						`Failed to rename "${categoryName}".\n\n` +
						`Error: ${error.message || 'Unknown error occurred'}\n\n` +
						`ğŸ’¡ Please try again or refresh the page.`
					);
					return false;
				}
			}

			/**
			 * Deletes a category and migrates its templates to a fallback category
			 * Implements atomic operations with full rollback on failure
			 * 
			 * @param {string} categoryId - Category identifier
			 * @returns {Promise<boolean>}
			 */
			async deleteCategory(categoryId) {
				let backup = null;
				let modificationsApplied = false;
				
				try {
					if (!categoryId || categoryId === 'toate') {
						ToastManager.error(
							`Cannot delete "All Categories"!\n\n` +
							`This is a special category that cannot be removed.`
						);
						return false;
					}
					
					const category = this.categories.find(c => c.id === categoryId);
					if (!category) {
						ToastManager.warning(
							`Category not found!\n\n` +
							`It may have been deleted in another tab. Please refresh the page.`
						);
						return false;
					}
					
					const affectedTemplates = this.templates.filter(t => t.category === categoryId);
					const fallbackCategory = this.categories.find(c => 
						c.id !== 'toate' && c.id !== categoryId
					);
					
					if (affectedTemplates.length > 0 && !fallbackCategory) {
						const otherCategories = this.categories.filter(c => c.id !== 'toate' && c.id !== categoryId).length;
						
						ToastManager.error(
							`Cannot delete "${category.name}" ${category.emoji}!\n\n` +
							`ğŸ“‹ This category has ${affectedTemplates.length} template${affectedTemplates.length !== 1 ? 's' : ''}.\n\n` +
							`âš ï¸ You need at least 2 categories (besides "All") when templates exist.\n\n` +
							`ğŸ’¡ Solution:\n` +
							`1. Create a new category first\n` +
							`2. Then try deleting "${category.name}"\n\n` +
							`Templates will be moved to the other category automatically.`
						);
						return false;
					}
					
					let confirmMessage;
					
					if (affectedTemplates.length > 0 && fallbackCategory) {
						confirmMessage = 
							`Delete category "${category.name}" ${category.emoji}?\n\n` +
							`ğŸ“‹ ${affectedTemplates.length} template${affectedTemplates.length !== 1 ? 's' : ''} will be moved to:\n` +
							`${fallbackCategory.emoji} "${fallbackCategory.name}"\n\n` +
							`This action cannot be undone.`;
					} else {
						const otherCategoriesCount = this.categories.filter(c => c.id !== 'toate' && c.id !== categoryId).length;
						confirmMessage = 
							`Delete empty category "${category.name}" ${category.emoji}?\n\n` +
							`ğŸ“Š You will have ${otherCategoriesCount} categor${otherCategoriesCount !== 1 ? 'ies' : 'y'} remaining.`;
					}
					
					const confirmed = await DialogManager.confirm({
						title: 'Delete Category',
						message: confirmMessage,
						confirmText: 'Delete',
						cancelText: 'Cancel',
						type: 'danger'
					});
					
					if (!confirmed) return false;
					
					backup = {
						categories: JSON.parse(JSON.stringify(this.categories)),
						templates: JSON.parse(JSON.stringify(this.templates)),
						activeCategory: this.activeCategory
					};
					
					if (fallbackCategory && affectedTemplates.length > 0) {
						let nextOrder = this.getNextOrder(fallbackCategory.id);
						
						affectedTemplates.forEach(template => {
							const templateIndex = this.templates.findIndex(t => t.id === template.id);
							if (templateIndex !== -1) {
								this.templates[templateIndex].category = fallbackCategory.id;
								this.templates[templateIndex].order = nextOrder++;
							}
						});
					}
					
					this.categories = this.categories.filter(c => c.id !== categoryId);
					
					if (this.activeCategory === categoryId) {
						this.activeCategory = 'toate';
					}
					
					modificationsApplied = true;
					
					const result = await this.saveData();
					
					if (result.success) {
						this.renderUI({ all: true });
						
						let successMessage;
						
						if (affectedTemplates.length > 0 && fallbackCategory) {
							const templatesInFallback = this.templates.filter(t => t.category === fallbackCategory.id).length;
							
							successMessage = 
								`ğŸ—‘ï¸ Category "${category.name}" deleted!\n\n` +
								`ğŸ“¦ ${affectedTemplates.length} template${affectedTemplates.length !== 1 ? 's' : ''} moved to ${fallbackCategory.emoji} "${fallbackCategory.name}"\n\n` +
								`ğŸ“Š "${fallbackCategory.name}" now has ${templatesInFallback} template${templatesInFallback !== 1 ? 's' : ''}.`;
						} else {
							const remainingCategories = this.categories.filter(c => c.id !== 'toate').length;
							
							successMessage = 
								`ğŸ—‘ï¸ Category "${category.name}" deleted successfully!\n\n` +
								`ğŸ“Š ${remainingCategories} categor${remainingCategories !== 1 ? 'ies' : 'y'} remaining.`;
						}
						
						ToastManager.success(successMessage);
						return true;
					} else {
						this.categories = backup.categories;
						this.templates = backup.templates;
						this.activeCategory = backup.activeCategory;
						
						this.renderUI({ all: true });
						
						ToastManager.error(
							result.message || 
							`Failed to delete category "${category.name}".\n\n` +
							`All changes have been reverted.\n\n` +
							`ğŸ’¡ Please try again or check your storage space.`
						);
						return false;
					}
					
				} catch (error) {
					console.error('Delete category error:', error);
					
					if (modificationsApplied && backup) {
						this.categories = backup.categories;
						this.templates = backup.templates;
						this.activeCategory = backup.activeCategory;
						
						this.renderUI({ all: true });
						
						console.log('Rolled back category deletion due to error');
					}
					
					ToastManager.error(
						`Failed to delete category.\n\n` +
						`Error: ${error.message || 'Unknown error occurred'}\n\n` +
						`ğŸ’¡ All changes have been reverted. Please try again or refresh the page.`
					);
					return false;
				}
			}

			/* ========================================================================
			   ğŸ” FILTERING & SEARCH
			   ======================================================================== */

			/**
			 * SeteazÄƒ categoria activÄƒ È™i updateazÄƒ UI
			 * @param {string} categoryId
			 * @returns {boolean} True dacÄƒ categoria a fost setatÄƒ cu succes
			 */
			setActiveCategory(categoryId) {
				try {
					if (!categoryId) {
						console.error('Category ID is required');
						ToastManager.error('Cannot switch category: ID is missing!');
						return false;
					}
					
					const category = this.categories.find(c => c.id === categoryId);
					if (!category) {
						console.warn('Category not found:', categoryId);
						ToastManager.warning(
							`Category not found!\n\n` +
							`It may have been deleted. Please refresh the page.`
						);
						return false;
					}
					
					if (this.activeCategory === categoryId) {
						console.log(`Category "${category.name}" ${category.emoji} already active`);
						return true;
					}
					
					const previousCategory = this.activeCategory;
					this.activeCategory = categoryId;
					
					const safeColor = (category.color && Utils.isValidColor(category.color)) 
						? category.color 
						: '#667eea';
					
					const allCategoryItems = document.querySelectorAll('.category-item');
					allCategoryItems.forEach(item => {
						const itemCategoryId = item.dataset.categoryId;
						
						if (itemCategoryId === categoryId) {
							item.classList.add('active');
							item.style.setProperty('--category-color', safeColor);
							item.setAttribute('aria-selected', 'true');
						} else {
							item.classList.remove('active');
							item.style.removeProperty('--category-color');
							item.setAttribute('aria-selected', 'false');
						}
					});
					
					if (this.smartSearch && this.smartSearch.state.isOpen) {
						this.smartSearch.close();
					}
					
					this.renderUI({ templates: true });
					
					return true;
					
				} catch (error) {
					console.error('Set active category error:', error);
					ToastManager.error(
						`Failed to switch category.\n\n` +
						`${error.message || 'Please try again.'}`
					);
					return false;
				}
			}

			/**
			 * ReturneazÄƒ templates filtrate È™i sortate
			 * Sortare: 
			 *   - Cu search: relevanÈ›Äƒ (NAME â†’ CONTENT â†’ TAGS) â†’ category â†’ order â†’ alfabetic
			 *   - FÄƒrÄƒ search: category â†’ order â†’ alfabetic
			 * @returns {Array} Array de template-uri filtrate È™i sortate
			 */
			getFilteredTemplates() {
				try {
					// ValidÄƒri
					if (!Array.isArray(this.templates)) {
						console.error('Templates is not an array');
						return [];
					}
					
					if (this.templates.length === 0) {
						return [];
					}
					
					let filtered = this.templates;
					let hasSearch = false;
					
					// ============================================
					// FILTRARE PE CATEGORIE
					// ============================================
					if (this.activeCategory && this.activeCategory !== 'toate') {
						filtered = filtered.filter(template => {
							if (!template || typeof template !== 'object') {
								return false;
							}
							return template.category === this.activeCategory;
						});
					}
					
					// ============================================
					// FILTRARE PE SEARCH TERM
					// ============================================
					if (this.searchTerm?.trim()) {
						hasSearch = true;
						
						// Helper inline pentru normalizare diacritice
						const removeDiacritics = (text) => {
							if (!text) return '';
							const map = {
								'Äƒ': 'a', 'Ã¢': 'a', 'Ã®': 'i', 'È™': 's', 'È›': 't',
								'Ä‚': 'A', 'Ã‚': 'A', 'Ã': 'I', 'È˜': 'S', 'Èš': 'T',
								'Ã¡': 'a', 'Ã ': 'a', 'Ã¤': 'a', 'Ã©': 'e', 'Ã¨': 'e', 'Ã«': 'e',
								'Ã­': 'i', 'Ã¬': 'i', 'Ã¯': 'i', 'Ã³': 'o', 'Ã²': 'o', 'Ã¶': 'o',
								'Ãº': 'u', 'Ã¹': 'u', 'Ã¼': 'u', 'Ã±': 'n', 'Ã§': 'c'
							};
							return text.split('').map(c => map[c] || c).join('');
						};
						
						// NormalizeazÄƒ È™i sparge Ã®n cuvinte
						const normalizedSearch = removeDiacritics(this.searchTerm.toLowerCase().trim());
						const searchTerms = normalizedSearch.split(/\s+/).filter(t => t.length > 0);
						
						if (searchTerms.length > 0) {
							// Cache normalizÄƒrile pentru fiecare template
							const normalizedTemplates = filtered.map(template => ({
								original: template,
								name: removeDiacritics((template.name || '').toLowerCase()),
								content: removeDiacritics((template.content || '').toLowerCase()),
								tags: (template.tags || []).map(tag => removeDiacritics((tag || '').toLowerCase()))
							}));
							
							// Filtrare: toate cuvintele trebuie prezente
							const matchedTemplates = normalizedTemplates.filter(normalized => {
								if (!normalized.original || typeof normalized.original !== 'object') {
									return false;
								}
								
								const tagsStr = normalized.tags.join(' ');
								const combined = `${normalized.name} ${normalized.content} ${tagsStr}`;
								
								// TOATE termenii trebuie prezenÈ›i (AND logic)
								return searchTerms.every(term => combined.includes(term));
							});
							
							// CalculeazÄƒ scor de relevanÈ›Äƒ pentru fiecare template
							filtered = matchedTemplates.map(normalized => {
								let score = 0;
								
								searchTerms.forEach(term => {
									// Prioritate 1: Match Ã®n NAME (100 puncte)
									if (normalized.name.includes(term)) {
										score += 100;
										
										// Exact match
										if (normalized.name === term) {
											score += 100; // Bonus match exact
										}
										// Starts with (DOAR dacÄƒ NU e exact match)
										else if (normalized.name.startsWith(term)) {
											score += 50; // Bonus Ã®nceput
										}
									}
									
									// Prioritate 2: Match Ã®n CONTENT (50 puncte)
									if (normalized.content.includes(term)) {
										score += 50;
									}
									
									// Prioritate 3: Match Ã®n TAGS (10 puncte)
									let hasTagMatch = false;
									let hasExactTagMatch = false;
									
									for (const tag of normalized.tags) {
										if (tag.includes(term)) {
											hasTagMatch = true;
											if (tag === term) {
												hasExactTagMatch = true;
											}
										}
									}
									
									if (hasTagMatch) score += 10;
									if (hasExactTagMatch) score += 5;
								});
								
								return { ...normalized.original, __searchRelevanceScore__: score };
							});
						}
					}
					
					// Early return pentru array gol
					if (filtered.length === 0) {
						return [];
					}
					
					// ============================================
					// CREARE CATEGORY INDEX MAP
					// ============================================
					const categoryIndexMap = new Map();
					if (Array.isArray(this.categories)) {
						this.categories.forEach((category, index) => {
							if (category?.id) {
								categoryIndexMap.set(category.id, index);
							}
						});
					}
					
					// ============================================
					// SORTARE
					// ============================================
					const sorted = filtered.sort((a, b) => {
						// Nivel 0: RelevanÈ›Äƒ (DOAR cÃ¢nd existÄƒ search)
						if (hasSearch) {
							const scoreA = a.__searchRelevanceScore__ || 0;
							const scoreB = b.__searchRelevanceScore__ || 0;
							
							if (scoreA !== scoreB) {
								return scoreB - scoreA; // DescrescÄƒtor
							}
						}
						
						// Nivel 1: Categorie
						const categoryA = a.category || '';
						const categoryB = b.category || '';
						
						if (categoryA !== categoryB) {
							const indexA = categoryIndexMap.get(categoryA);
							const indexB = categoryIndexMap.get(categoryB);
							
							if (indexA !== undefined && indexB !== undefined) {
								return indexA - indexB;
							}
							
							if (indexA === undefined) return 1;
							if (indexB === undefined) return -1;
						}
						
						// Nivel 2: Order manual
						const orderA = typeof a.order === 'number' ? a.order : 0;
						const orderB = typeof b.order === 'number' ? b.order : 0;
						
						if (orderA !== orderB) {
							return orderA - orderB;
						}
						
						// Nivel 3: Alfabetic
						const nameA = (a.name || '').toLowerCase();
						const nameB = (b.name || '').toLowerCase();
						
						return nameA.localeCompare(nameB);
					});
					
					// EliminÄƒ scorul temporar
					if (hasSearch) {
						return sorted.map(({ __searchRelevanceScore__, ...template }) => template);
					}
					
					return sorted;
					
				} catch (error) {
					console.error('Get filtered templates error:', error);
					return [];
				}
			}

			/**
			 * CalculeazÄƒ statistici pentru dashboard
			 * @returns {Object} Statistici: total, active, categories, recent
			 */
			getStats() {
				try {
					if (!Array.isArray(this.templates) || !Array.isArray(this.categories)) {
						console.error('Invalid templates or categories array');
						return { total: 0, active: 0, categories: 0, recent: 0 };
					}
					
					const weekAgo = new Date();
					weekAgo.setDate(weekAgo.getDate() - 7);
					const weekAgoTime = weekAgo.getTime();
					
					const stats = this.templates.reduce((acc, t) => {
						if (!t) return acc;
						
						if (t.active) {
							acc.active++;
						}
						
						if (t.createdAt) {
							const date = new Date(t.createdAt);
							const dateTime = date.getTime();
							
							if (!isNaN(dateTime) && dateTime > weekAgoTime) {
								acc.recent++;
							}
						}
						
						return acc;
					}, { active: 0, recent: 0 });
					
					return {
						total: this.templates.length,
						active: stats.active,
						categories: this.categories.filter(c => c?.id !== 'toate').length,
						recent: stats.recent
					};
					
				} catch (error) {
					console.error('Get stats error:', error);
					return { total: 0, active: 0, categories: 0, recent: 0 };
				}
			}

            /* ========================================================================
               ğŸ¨ RENDERING
               ======================================================================== */

			/**
			 * FuncÈ›ie centralizatÄƒ de rendering cu opÈ›iuni flexibile
			 * Permite render complet sau parÈ›ial pentru optimizare performanÈ›Äƒ
			 * Try-catch individual pentru fiecare secÈ›iune pentru izolare erori
			 * 
			 * @param {Object} options - OpÈ›iuni de rendering
			 * @param {boolean} options.all - Full render (toate secÈ›iunile)
			 * @param {boolean} options.categories - Re-render complet listÄƒ categorii
			 * @param {boolean} options.templates - Re-render complet grid templates
			 * @param {boolean} options.stats - Re-render statistici dashboard
			 * @param {boolean} options.categorySelect - Update dropdown categorii Ã®n formular
			 * @param {boolean} options.categoryCounts - Update doar counts (optimizat, fÄƒrÄƒ DOM rebuild)
			 * @param {string|null} options.templateCard - ID template pentru update individual
			 * @param {boolean} options.silent - SuprimÄƒ error toasts (folosit Ã®n operaÈ›ii batch)
			 */
			renderUI(options = {}) {
				const {
					all = false,
					categories = false,
					templates = false,
					stats = false,
					categorySelect = false,
					categoryCounts = false,
					templateCard = null,
					silent = false
				} = options;
				
				const operations = [];
				let hasErrors = false;
				
				if (all) {
					// Categories
					try {
						operations.push('categories');
						this.renderCategories();
					} catch (error) {
						hasErrors = true;
						console.error('Error rendering categories:', error);
						if (!silent) {
							ToastManager.error('Failed to render categories section');
						}
					}
					
					// Templates
					try {
						operations.push('templates');
						this.renderTemplates();
					} catch (error) {
						hasErrors = true;
						console.error('Error rendering templates:', error);
						if (!silent) {
							ToastManager.error('Failed to render templates section');
						}
					}
					
					// Stats
					try {
						operations.push('stats');
						this.renderStats();
					} catch (error) {
						hasErrors = true;
						console.error('Error rendering stats:', error);
						// Stats nu afiÈ™eazÄƒ toast, doar log
					}
					
					return;
				}
				
				if (categories) {
					try {
						operations.push('categories');
						this.renderCategories();
					} catch (error) {
						hasErrors = true;
						console.error('Error rendering categories:', error);
						if (!silent) {
							ToastManager.error('Failed to render categories section');
						}
					}
				} else if (categoryCounts) {
					try {
						operations.push('category-counts');
						this.updateCategoryCounts();
					} catch (error) {
						hasErrors = true;
						console.error('Error updating category counts:', error);
						if (!silent) {
							ToastManager.error('Failed to update category counts');
						}
					}
				}
				
				if (templates) {
					try {
						operations.push('templates');
						this.renderTemplates();
					} catch (error) {
						hasErrors = true;
						console.error('Error rendering templates:', error);
						if (!silent) {
							ToastManager.error('Failed to render templates section');
						}
					}
				} else if (templateCard) {
					try {
						operations.push(`template-card:${templateCard}`);
						this.updateTemplateCard(templateCard);
					} catch (error) {
						hasErrors = true;
						console.error('Error updating template card:', error);
						if (!silent) {
							ToastManager.error('Failed to update template');
						}
					}
				}
				
				if (stats) {
					try {
						operations.push('stats');
						this.renderStats();
					} catch (error) {
						hasErrors = true;
						console.error('Error rendering stats:', error);
						// Stats nu afiÈ™eazÄƒ toast, doar log
					}
				}
				
				if (categorySelect) {
					try {
						operations.push('category-select');
						this.populateCategorySelect();
					} catch (error) {
						hasErrors = true;
						console.error('Error populating category select:', error);
						if (!silent) {
							ToastManager.error('Failed to update category dropdown');
						}
					}
				}
				
				if (operations.length === 0 && !silent) {
					console.warn('renderUI() called without any operations specified');
				}
			}

			/**
			 * RenderizeazÄƒ lista de categorii
			 */
			renderCategories() {
				try {
					const list = document.getElementById('categoryList');
					
					if (!list) {
						console.warn('Category list element not found');
						return;
					}
					
					list.innerHTML = '';

					const counts = this.calculateCategoryCounts();
					const fragment = document.createDocumentFragment();

					this.categories.forEach(category => {
						const count = counts[category.id] || 0;
						const li = this.createCategoryListItem(category, count);
						fragment.appendChild(li);
					});

					list.appendChild(fragment);
					
					this.populateCategorySelect();
					
				} catch (error) {
					console.error('Render categories error:', error);
				}
			}

			/**
			 * RenderizeazÄƒ templates cu filtrare
			 */
			renderTemplates() {
				try {
					const grid = document.getElementById('templatesGrid');
					
					if (!grid) {
						console.warn('Templates grid element not found');
						return;
					}
					
					const templates = this.getFilteredTemplates();

					grid.innerHTML = '';

					if (templates.length === 0) {
						this.showEmptyState();
						return;
					}

					const fragment = document.createDocumentFragment();
					const categoryMap = this.createCategoryMap();

					templates.forEach(template => {
						const card = this.createTemplateCard(template, categoryMap);
						fragment.appendChild(card);
					});

					grid.appendChild(fragment);
					
				} catch (error) {
					console.error('Render templates error:', error);
				}
			}

			/**
			 * RenderizeazÄƒ statistici
			 */
			renderStats() {
				try {
					const stats = this.getStats();
					const grid = document.getElementById('statsGrid');

					if (!grid) {
						console.warn('Stats grid element not found');
						return;
					}

					grid.innerHTML = '';

					const statsData = [
						{ label: 'Total Templates', value: stats.total },
						{ label: 'Active Templates', value: stats.active },
						{ label: 'Categories', value: stats.categories },
						{ label: 'Recent (7 days)', value: stats.recent }
					];

					const fragment = document.createDocumentFragment();

					statsData.forEach(stat => {
						const card = document.createElement('div');
						card.className = 'stat-card';

						const number = document.createElement('div');
						number.className = 'stat-number';
						number.textContent = stat.value;

						const label = document.createElement('div');
						label.className = 'stat-label';
						label.textContent = stat.label;

						card.append(number, label);
						fragment.appendChild(card);
					});

					grid.appendChild(fragment);
					
				} catch (error) {
					console.error('Render stats error:', error);
				}
			}

			/**
			 * PopuleazÄƒ dropdown cu categorii pentru formular
			 * PÄƒstreazÄƒ selecÈ›ia curentÄƒ dupÄƒ repopulare
			 */
			populateCategorySelect() {
				try {
					const select = document.getElementById('templateCategory');
					
					if (!select) {
						console.warn('Category select element not found');
						return;
					}
					
					if (!Array.isArray(this.categories)) {
						console.error('Categories is not an array');
						return;
					}
					
					const currentValue = select.value;
					
					select.innerHTML = '<option value="">Select Category</option>';

					this.categories.forEach(category => {
						if (category?.id !== 'toate') {
							const option = document.createElement('option');
							option.value = category.id;
							
							const emoji = category.emoji ? `${category.emoji} ` : '';
							const name = category.name || 'Unnamed';
							option.textContent = emoji + name;
							
							select.appendChild(option);
						}
					});
					
					if (currentValue && this.categories.some(c => c?.id === currentValue)) {
						select.value = currentValue;
					}
					
				} catch (error) {
					console.error('Populate category select error:', error);
				}
			}

			/**
			 * UpdateazÄƒ counts pentru categorii fÄƒrÄƒ full re-render
			 */
			updateCategoryCounts() {
				try {
					const counts = this.calculateCategoryCounts();
					
					this.categories.forEach(category => {
						const count = counts[category.id] || 0;
						
						const countEl = document.querySelector(
							`[data-category-id="${category.id}"] .category-count`
						);

						if (countEl) {
							countEl.textContent = count;
							countEl.setAttribute('aria-label', `${count} templates`);
						}
					});
					
				} catch (error) {
					console.error('Update category counts error:', error);
				}
			}

			/**
			 * UpdateazÄƒ un template card individual
			 * @param {string} id
			 */
			updateTemplateCard(id) {
				try {
					if (!id) {
						console.warn('Template ID required for update');
						return;
					}
					
					const template = this.templates.find(t => t.id === id);
					if (!template) {
						console.warn('Template not found for update:', id);
						return;
					}

					const oldCard = document.querySelector(`[data-template-id="${id}"]`);
					if (oldCard) {
						const newCard = this.createTemplateCard(template);
						
						if (oldCard.replaceWith) {
							oldCard.replaceWith(newCard);
						} else {
							oldCard.parentNode.replaceChild(newCard, oldCard);
						}
					}
					
				} catch (error) {
					console.error('Update template card error:', error);
				}
			}

			/**
			 * CreeazÄƒ un list item pentru categorie
			 * @param {Object} category
			 * @param {number} count
			 * @returns {HTMLElement}
			 */
			createCategoryListItem(category, count) {
				try {
					const li = document.createElement('li');
					li.setAttribute('role', 'presentation');

					const button = document.createElement('button');
					button.className = `category-item ${this.activeCategory === category.id ? 'active' : ''}`;
					button.setAttribute('role', 'tab');
					button.setAttribute('aria-selected', this.activeCategory === category.id);
					button.setAttribute('aria-controls', 'templatesGrid');
					button.dataset.categoryId = category.id;
					
					if (this.activeCategory === category.id) {
						const safeColor = (category.color && Utils.isValidColor(category.color)) 
							? category.color 
							: '#667eea';
						button.style.setProperty('--category-color', safeColor);
					}

					const emoji = document.createElement('span');
					emoji.className = 'category-emoji';
					emoji.setAttribute('aria-hidden', 'true');
					emoji.textContent = category.emoji || 'ğŸ“';

					const name = document.createElement('span');
					name.className = 'category-name';
					name.textContent = category.name || 'Unnamed';

					button.append(emoji, name);

					if (category.id !== 'toate') {
						const actions = document.createElement('div');
						actions.className = 'category-actions';

						const editBtn = document.createElement('button');
						editBtn.className = 'category-btn';
						editBtn.dataset.action = 'edit';
						editBtn.setAttribute('aria-label', `Edit ${category.name}`);
						editBtn.textContent = 'âœï¸';

						const deleteBtn = document.createElement('button');
						deleteBtn.className = 'category-btn';
						deleteBtn.dataset.action = 'delete';
						deleteBtn.setAttribute('aria-label', `Delete ${category.name}`);
						deleteBtn.textContent = 'ğŸ—‘ï¸';

						actions.append(editBtn, deleteBtn);
						button.appendChild(actions);
					}

					const countSpan = document.createElement('span');
					countSpan.className = 'category-count';
					countSpan.setAttribute('aria-label', `${count} templates`);
					countSpan.textContent = count;

					button.appendChild(countSpan);
					li.appendChild(button);
					
					return li;
					
				} catch (error) {
					console.error('Create category list item error:', error);
					return document.createElement('li');
				}
			}

			/**
			 * CreeazÄƒ card pentru template
			 * @param {Object} template
			 * @param {Map} categoryMap
			 * @returns {HTMLElement}
			 */
			createTemplateCard(template, categoryMap = null) {
				try {
					if (!template || !template.id) {
						console.warn('Invalid template for card creation');
						return document.createElement('article');
					}
					
					const category = categoryMap 
						? categoryMap.get(template.category)
						: this.categories.find(c => c.id === template.category);

					const card = document.createElement('article');
					card.className = 'template-card';
					card.draggable = true;
					card.dataset.templateId = template.id;

					const dragHandle = document.createElement('div');
					dragHandle.className = 'drag-handle';
					dragHandle.setAttribute('aria-label', 'Drag to reorder');
					dragHandle.textContent = 'â‹®â‹®';

					const title = document.createElement('h3');
					title.className = 'template-title';
					title.textContent = template.name || 'Unnamed Template';

					const categoryBadge = document.createElement('div');
					categoryBadge.className = 'template-category';
					const safeColor = (category?.color && Utils.isValidColor(category.color)) 
						? category.color 
						: '#667eea';
					categoryBadge.style.background = safeColor;
					
					card.style.setProperty('--category-color', safeColor);
					
					const badgeEmoji = document.createElement('span');
					badgeEmoji.setAttribute('aria-hidden', 'true');
					badgeEmoji.textContent = category?.emoji || 'ğŸ“';
					
					const badgeName = document.createTextNode(` ${category?.name || 'Unknown'}`);
					
					categoryBadge.appendChild(badgeEmoji);
					categoryBadge.appendChild(badgeName);

					const content = document.createElement('div');
					content.className = 'template-content';
					content.setAttribute('role', 'text');
					content.textContent = template.content || '';

					card.append(dragHandle, title, categoryBadge, content);

					if (Array.isArray(template.tags) && template.tags.length > 0) {
						const tagsContainer = document.createElement('div');
						tagsContainer.className = 'template-tags';

						template.tags.forEach(tag => {
							if (typeof tag === 'string' && tag.trim()) {
								const tagSpan = document.createElement('span');
								tagSpan.className = 'tag';
								tagSpan.textContent = tag.trim();
								tagsContainer.appendChild(tagSpan);
							}
						});

						if (tagsContainer.children.length > 0) {
							card.appendChild(tagsContainer);
						}
					}

					const actions = document.createElement('footer');
					actions.className = 'template-actions';
					actions.setAttribute('role', 'group');
					actions.setAttribute('aria-label', 'Template actions');

					const copyBtn = this.createActionButton('copy', 'ğŸ“‹ Copy', 'Copy template content');
					const editBtn = this.createActionButton('edit', 'âœï¸ Edit', 'Edit template');
					const deleteBtn = this.createActionButton('delete', 'ğŸ—‘ï¸ Delete', 'Delete template');

					actions.append(copyBtn, editBtn, deleteBtn);
					card.appendChild(actions);

					return card;
					
				} catch (error) {
					console.error('Create template card error:', error);
					return document.createElement('article');
				}
			}

			/**
			 * CreeazÄƒ button pentru template actions
			 * @param {string} action
			 * @param {string} text
			 * @param {string} ariaLabel
			 * @returns {HTMLElement}
			 */
			createActionButton(action, text, ariaLabel) {
				const btn = document.createElement('button');
				btn.type = 'button';
				btn.dataset.action = action;
				btn.setAttribute('aria-label', ariaLabel);
				btn.textContent = text;
				return btn;
			}

			/**
			 * CalculeazÄƒ counts pentru toate categoriile Ã®ntr-un singur loop
			 * @returns {Object} Map cu category ID ca key È™i count ca value
			 */
			calculateCategoryCounts() {
				try {
					const counts = {};
					
					const categoriesSnapshot = [...this.categories];
					
					categoriesSnapshot.forEach(c => {
						counts[c.id] = 0;
					});
					
					this.templates.forEach(t => {
						if (t && t.category) {
							if (!counts.hasOwnProperty(t.category)) {
								counts[t.category] = 0;
							}
							counts[t.category]++;
						}
					});
					
					counts['toate'] = this.templates.filter(t => t && t.category).length;
					
					return counts;
					
				} catch (error) {
					console.error('Calculate category counts error:', error);
					return {};
				}
			}

			/**
			 * CreeazÄƒ map pentru category lookup rapid
			 * @returns {Map}
			 */
			createCategoryMap() {
				try {
					const map = new Map();
					
					this.categories.forEach(c => {
						map.set(c.id, c);
					});
					
					return map;
					
				} catch (error) {
					console.error('Create category map error:', error);
					return new Map();
				}
			}

            /* ========================================================================
               ğŸ“‹ MODAL MANAGEMENT
               ======================================================================== */

			/**
			 * Deschide modal pentru add/edit template
			 * @param {Object|null} template
			 */
			openModal(template = null) {
				try {
					const modal = document.getElementById('templateModal');
					const title = document.getElementById('modalTitle');
					const form = document.getElementById('templateForm');

					if (!modal || !title || !form) {
						console.error('Modal elements not found');
						ToastManager.error('Failed to open editor. Please refresh the page.');
						return;
					}
					
					if (modal && modal.classList.contains('show')) {
						console.log('Modal already open');
						return;
					}

					if (template) {
						title.textContent = 'Edit Template';
						this.populateForm(template);
					} else {
						title.textContent = 'Add New Template';
						form.reset();
						this.editingTemplate = null;
					}

					modal.classList.add('show');

					this.lastFocusedElement = document.activeElement;

					setTimeout(() => {
						const firstInput = document.getElementById('templateName');
						if (firstInput) {
							firstInput.focus();
						}
					}, 100);

					document.body.style.overflow = 'hidden';
					
				} catch (error) {
					console.error('Open modal error:', error);
					ToastManager.error('Failed to open editor. Please try again.');
				}
			}

			/**
			 * Ãnchide modal
			 */
			closeModal() {
				try {
					const modal = document.getElementById('templateModal');
					const form = document.getElementById('templateForm');
					
					if (modal) {
						modal.classList.remove('show');
					}
					
					document.body.style.overflow = '';

					if (this.lastFocusedElement && document.body.contains(this.lastFocusedElement)) {
						this.lastFocusedElement.focus();
					} else {
						const searchBar = document.getElementById('searchBar');
						if (searchBar) {
							searchBar.focus();
						}
					}
					
					this.lastFocusedElement = null;
					this.editingTemplate = null;
					
					if (form) {
						form.reset();
					}
					
				} catch (error) {
					console.error('Close modal error:', error);
				}
			}

			/**
			 * PopuleazÄƒ formul cu date template
			 * @param {Object} template
			 */
			populateForm(template) {
				try {
					if (!template) {
						console.warn('No template provided to populate form');
						return;
					}
					
					const nameInput = document.getElementById('templateName');
					const categoryInput = document.getElementById('templateCategory');
					const contentInput = document.getElementById('templateContent');
					const tagsInput = document.getElementById('templateTags');
					
					if (!nameInput || !categoryInput || !contentInput || !tagsInput) {
						console.error('Form inputs not found');
						return;
					}
					
					nameInput.value = template.name || '';
					categoryInput.value = template.category || '';
					contentInput.value = template.content || '';
					tagsInput.value = Array.isArray(template.tags) ? template.tags.join(', ') : '';
					
				} catch (error) {
					console.error('Populate form error:', error);
				}
			}

			/**
			 * ProceseazÄƒ submit formular template
			 * ValideazÄƒ input-ul È™i creeazÄƒ/actualizeazÄƒ template-ul
			 */
			async handleFormSubmit() {
				try {
					const nameInput = document.getElementById('templateName');
					const categoryInput = document.getElementById('templateCategory');
					const contentInput = document.getElementById('templateContent');
					const tagsInput = document.getElementById('templateTags');
					
					if (!nameInput || !categoryInput || !contentInput || !tagsInput) {
						console.error('Form elements not found');
						ToastManager.error('Form error. Please refresh the page.');
						return;
					}
					
					const name = nameInput.value.trim();
					const category = categoryInput.value;
					const content = contentInput.value.trim();
					const tagsInputValue = tagsInput.value.trim();
					
					if (!category || category.trim() === '') {
						ToastManager.error('Please select a category.');
						categoryInput.focus();
						return;
					}
					
					if (category === 'toate') {
						ToastManager.error('Cannot assign template to "Toate" category. Please select a specific category.');
						categoryInput.focus();
						return;
					}
					
					const categoryExists = this.categories.some(c => c.id === category);
					
					if (!categoryExists) {
						ToastManager.error('Selected category no longer exists. Please select another category.');
						this.renderUI({ categorySelect: true });
						categoryInput.focus();
						return;
					}
					
					let tags = [];
					if (tagsInputValue) {
						const originalTags = tagsInputValue
							.split(',')
							.map(t => t.trim())
							.filter(t => t.length > 0 && t.length <= 50);
						
						const seenTags = new Set();
						tags = originalTags.filter(tag => {
							const lowerTag = tag.toLowerCase();
							if (seenTags.has(lowerTag)) {
								return false;
							}
							seenTags.add(lowerTag);
							return true;
						}).slice(0, 3);
						
						if (tags.length < originalTags.length) {
							tagsInput.value = tags.join(', ');
						}
					}

					const templateData = { name, category, content, tags };

					const excludeId = this.editingTemplate?.id || null;
					const validation = Validators.validateTemplateInput(
						templateData, 
						this.templates, 
						this.categories, 
						excludeId
					);
					
					if (!validation.valid) {
						const errorMessage = validation.errors[0];
						ToastManager.error(errorMessage);
						
						const errorLower = errorMessage.toLowerCase();
						
						if (errorLower.includes('name')) {
							nameInput.focus();
							nameInput.select();
						} else if (errorLower.includes('category')) {
							categoryInput.focus();
						} else if (errorLower.includes('content')) {
							contentInput.focus();
							contentInput.select();
						} else if (errorLower.includes('tag')) {
							tagsInput.focus();
							tagsInput.select();
						}
						
						return;
					}
					
					let success = false;

					if (this.editingTemplate) {
						success = await this.updateTemplate(this.editingTemplate.id, templateData);
					} else {
						success = await this.addTemplate(templateData);
					}

					if (success) {
						this.closeModal();
					} else {
						console.warn('Form submit failed - modal remains open for corrections');
					}
				} catch (error) {
					console.error('Form submit error:', error);
					ToastManager.error('An unexpected error occurred. Please try again.');
				}
			}

            /* ========================================================================
               ğŸ’¾ IMPORT/EXPORT
               ======================================================================== */

			/**
			 * ExportÄƒ templates È™i categorii ca JSON
			 * @returns {boolean}
			 */
			exportData() {
				try {
					if (!this.templates || !this.categories) {
						console.error('Invalid data for export');
						ToastManager.error('Cannot export: Invalid data!');
						return false;
					}
					
					if (!Array.isArray(this.templates) || !Array.isArray(this.categories)) {
						console.error('Templates or categories is not an array');
						ToastManager.error('Cannot export: Invalid data structure!');
						return false;
					}
					
					const now = new Date();
					const timestamp = now.toISOString();
					const dateStr = timestamp.split('T')[0];
					
					const data = {
						templates: this.templates,
						categories: this.categories,
						exportedAt: timestamp,
						version: '1.0'
					};
					
					const jsonString = JSON.stringify(data, null, 2);
					
					const blob = new Blob([jsonString], { 
						type: 'application/json;charset=utf-8' 
					});
					
					const sizeBytes = blob.size;
					const sizeMB = (sizeBytes / (1024 * 1024)).toFixed(2);
					
					if (sizeBytes > 10 * 1024 * 1024) {
						console.warn(`Large export: ${sizeMB} MB`);
					}
					
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					a.download = `template_manager_backup_${dateStr}.json`;
					a.style.display = 'none';
					
					document.body.appendChild(a);
					a.click();
					
					setTimeout(() => {
						document.body.removeChild(a);
						URL.revokeObjectURL(url);
					}, 1000);

					ToastManager.success(
						`Export completed (${this.templates.length} templates, ${sizeMB} MB)`
					);
					
					return true;
					
				} catch (error) {
					console.error('Export error:', error);
					
					if (error.name === 'QuotaExceededError') {
						ToastManager.error('Export failed: File too large for your browser!');
					} else {
						ToastManager.error('Error exporting data!');
					}
					
					return false;
				}
			}

			/**
			 * ImportÄƒ templates È™i categorii din JSON
			 * @param {Object} data
			 */
			async importData(data) {
				const backup = {
					categories: JSON.parse(JSON.stringify(this.categories)),
					templates: JSON.parse(JSON.stringify(this.templates)),
					activeCategory: this.activeCategory
				};
				
				try {
					if (!data || typeof data !== 'object') {
						ToastManager.error('Invalid file format!');
						return;
					}

					if (!Array.isArray(data.templates) || !Array.isArray(data.categories)) {
						ToastManager.error('Invalid data structure! Missing templates or categories.');
						return;
					}

					if (data.version && typeof data.version === 'string' && data.version !== '1.0') {
						const proceed = await DialogManager.confirm({
							title: 'Version Mismatch',
							message: `This file was exported with version ${Utils.escapeHtml(data.version)}. Current version is 1.0. Import anyway?`,
							confirmText: 'Import',
							cancelText: 'Cancel',
							type: 'warning'
						});
						
						if (!proceed) return;
					}

					const validatedTemplates = Validators.validateTemplates(data.templates);
					const validatedCategories = Validators.validateCategories(data.categories);

					if (validatedCategories.length === 0) {
						ToastManager.error('No valid categories found in import file!');
						return;
					}

					let categoriesToImport = [...validatedCategories];
					if (!categoriesToImport.find(c => c.id === 'toate')) {
						categoriesToImport.unshift({
							id: 'toate',
							name: 'Toate',
							emoji: 'ğŸ“',
							color: '#667eea'
						});
					}

					const invalidTemplatesCount = data.templates.length - validatedTemplates.length;
					const invalidCategoriesCount = data.categories.length - validatedCategories.length;
					
					let warningMessage = '';
					if (invalidTemplatesCount > 0 || invalidCategoriesCount > 0) {
						warningMessage = '\n\nWarning: ';
						if (invalidTemplatesCount > 0) {
							warningMessage += `${invalidTemplatesCount} invalid templates will be skipped. `;
						}
						if (invalidCategoriesCount > 0) {
							warningMessage += `${invalidCategoriesCount} invalid categories will be skipped.`;
						}
					}

					const confirmed = await DialogManager.confirm({
						title: 'Import Data',
						message: `You are about to import ${validatedTemplates.length} templates and ${categoriesToImport.length} categories. This will overwrite all existing data.${warningMessage}\n\nContinue?`,
						confirmText: 'Import',
						cancelText: 'Cancel',
						type: 'warning'
					});

					if (!confirmed) return;

					this.categories = categoriesToImport;
					this.templates = validatedTemplates;
					this.activeCategory = 'toate';

					const saveResult = await this.saveData();
					
					if (saveResult.success) {
						this.renderUI({ all: true });
						
						let successMessage = `Imported ${validatedTemplates.length} templates and ${categoriesToImport.length} categories!`;
						
						if (invalidTemplatesCount > 0 || invalidCategoriesCount > 0) {
							successMessage += ` (${invalidTemplatesCount + invalidCategoriesCount} invalid items skipped)`;
						}
						
						ToastManager.success(successMessage, 5000);
					} else {
						this.categories = backup.categories;
						this.templates = backup.templates;
						this.activeCategory = backup.activeCategory;
						
						this.renderUI({ all: true });
						
						ToastManager.error(saveResult.message || 'Failed to save imported data. Your original data has been restored.', 5000);
					}
					
				} catch (error) {
					console.error('Import failed:', error);
					
					this.categories = backup.categories;
					this.templates = backup.templates;
					this.activeCategory = backup.activeCategory;
					this.renderUI({ all: true });
					
					const errorMessage = error.message || 'Unknown error';
					ToastManager.error(`Import failed: ${errorMessage}`, 5000);
				}
			}
			
			/**
			 * Cleanup method pentru a preveni memory leaks
			 * Trebuie apelatÄƒ Ã®nainte de re-iniÈ›ializare sau page navigation
			 */
			destroy() {
				try {
					// Cleanup toasts
					if (ToastManager.hideAll) {
						ToastManager.hideAll();
					}
					
					// Close modal
					this.closeModal();
					
					if (this.smartSearch && typeof this.smartSearch.destroy === 'function') {
						this.smartSearch.destroy();
						this.smartSearch = null;
					}
					
					// Cleanup dialog
					if (DialogManager.activeDialog) {
						if (DialogManager.activeDialog.parentNode) {
							DialogManager.activeDialog.remove();
						}
						DialogManager.activeDialog = null;
					}
					
					if (this.storageEventListener) {
						window.removeEventListener('storage', this.storageEventListener);
						this.storageEventListener = null;
					}
					
					if (this.syncTimeout) {
						clearTimeout(this.syncTimeout);
						this.syncTimeout = null;
					}
					
					if (this.eventHandlers.headerClick) {
						const headerActions = document.querySelector('.header-actions');
						if (headerActions) {
							headerActions.removeEventListener('click', this.eventHandlers.headerClick);
						}
					}
					
					if (this.eventHandlers.categoryClick) {
						const categoryList = document.getElementById('categoryList');
						if (categoryList) {
							categoryList.removeEventListener('click', this.eventHandlers.categoryClick);
						}
					}
					
					if (this.eventHandlers.addCategoryClick) {
						const addCategoryBtn = document.querySelector('.add-category');
						if (addCategoryBtn) {
							addCategoryBtn.removeEventListener('click', this.eventHandlers.addCategoryClick);
						}
					}
					
					if (this.eventHandlers.searchInput) {
						const searchBar = document.getElementById('searchBar');
						if (searchBar) {
							searchBar.removeEventListener('input', this.eventHandlers.searchInput);
						}
					}
					
					if (this.eventHandlers.searchClear) {
						const searchClear = document.getElementById('searchClear');
						if (searchClear) {
							searchClear.removeEventListener('click', this.eventHandlers.searchClear);
						}
					}
					
					if (this.eventHandlers.searchEscape) {
						const searchBar = document.getElementById('searchBar');
						if (searchBar) {
							searchBar.removeEventListener('keydown', this.eventHandlers.searchEscape);
						}
					}
					
					if (this.eventHandlers.emptyStateClick) {
						const grid = document.getElementById('templatesGrid');
						if (grid) {
							grid.removeEventListener('click', this.eventHandlers.emptyStateClick);
						}
					}
					
					if (this.eventHandlers.templateGridClick) {
						const grid = document.getElementById('templatesGrid');
						if (grid) {
							grid.removeEventListener('click', this.eventHandlers.templateGridClick);
						}
					}
					
					const grid = document.getElementById('templatesGrid');
					if (grid) {
						if (this.eventHandlers.gridDragStart) {
							grid.removeEventListener('dragstart', this.eventHandlers.gridDragStart);
						}
						if (this.eventHandlers.gridDragEnd) {
							grid.removeEventListener('dragend', this.eventHandlers.gridDragEnd);
						}
						if (this.eventHandlers.gridDragOver) {
							grid.removeEventListener('dragover', this.eventHandlers.gridDragOver);
						}
						if (this.eventHandlers.gridDragLeave) {
							grid.removeEventListener('dragleave', this.eventHandlers.gridDragLeave);
						}
						if (this.eventHandlers.gridDrop) {
							grid.removeEventListener('drop', this.eventHandlers.gridDrop);
						}
					}
					
					const categoryList = document.getElementById('categoryList');
					if (categoryList) {
						if (this.eventHandlers.categoryDragEnter) {
							categoryList.removeEventListener('dragenter', this.eventHandlers.categoryDragEnter);
						}
						if (this.eventHandlers.categoryDragOver) {
							categoryList.removeEventListener('dragover', this.eventHandlers.categoryDragOver);
						}
						if (this.eventHandlers.categoryDragLeave) {
							categoryList.removeEventListener('dragleave', this.eventHandlers.categoryDragLeave);
						}
						if (this.eventHandlers.categoryDrop) {
							categoryList.removeEventListener('drop', this.eventHandlers.categoryDrop);
						}
					}
					
					const modal = document.getElementById('templateModal');
					const form = document.getElementById('templateForm');
					
					if (modal && this.eventHandlers.modalMouseDown) {
						modal.removeEventListener('mousedown', this.eventHandlers.modalMouseDown);
					}

					if (modal && this.eventHandlers.modalMouseUp) {
						modal.removeEventListener('mouseup', this.eventHandlers.modalMouseUp);
					}
					
					if (modal && this.eventHandlers.modalClick) {
						modal.removeEventListener('click', this.eventHandlers.modalClick);
					}
					
					if (modal && this.eventHandlers.modalKeyDown) {
						modal.removeEventListener('keydown', this.eventHandlers.modalKeyDown);
					}
					
					if (form && this.eventHandlers.formSubmit) {
						form.removeEventListener('submit', this.eventHandlers.formSubmit);
					}
					
					if (this.eventHandlers.importChange) {
						const importFile = document.getElementById('import-file');
						if (importFile) {
							importFile.removeEventListener('change', this.eventHandlers.importChange);
						}
					}
					
					if (this.eventHandlers.keyboardShortcuts) {
						document.removeEventListener('keydown', this.eventHandlers.keyboardShortcuts);
					}
					
					this.eventHandlers = {
						headerClick: null,
						categoryClick: null,
						addCategoryClick: null,
						searchInput: null,
						searchClear: null,
						searchEscape: null,
						emptyStateClick: null,
						templateGridClick: null,
						gridDragStart: null,
						gridDragEnd: null,
						gridDragOver: null,
						gridDragLeave: null,
						gridDrop: null,
						categoryDragEnter: null,
						categoryDragOver: null,
						categoryDragLeave: null,
						categoryDrop: null,
						modalMouseDown: null,
						modalMouseUp: null,
						modalClick: null,
						modalKeyDown: null,
						formSubmit: null,
						importChange: null,
						keyboardShortcuts: null
					};
					
					if (this.debouncedSearch && typeof this.debouncedSearch.cancel === 'function') {
						this.debouncedSearch.cancel();
					}
					
					this.clearDropTargets();
					
					this.defaultCategories = null;
					this.categoryColors = null;
					this.categoryEmojis = null;
					this.templates = null;
					this.categories = null;
					this.activeCategory = null;
					this.searchTerm = null;
					this.editingTemplate = null;
					this.draggedTemplate = null;
					this.lastFocusedElement = null;
					this.storageEventListener = null;
					this.currentDropTargets = null;
					this.eventHandlers = null;
					this.debouncedSearch = null;
					
					console.log('TemplateManager cleanup completed');
					
				} catch (error) {
					console.error('Error during cleanup:', error);
				}
			}
        }

        /* ============================================================================
           ğŸš€ APPLICATION INITIALIZATION
           ============================================================================ */

        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp();
        }

		async function initApp() {
			try {
				if (window.appCleanupListener) {
					window.removeEventListener('beforeunload', window.appCleanupListener);
				}
				
				// Initialize the app
				window.app = new TemplateManager();
				await window.app.init();
				
				// Development helper
				if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
					console.log('ğŸš€ Template Manager initialized');
					console.log('ğŸ’¡ Access app instance via: window.app');
				}
				
				// Setup cleanup listener
				window.appCleanupListener = () => {
					if (window.app && typeof window.app.destroy === 'function') {
						window.app.destroy();
					}
				};
				
				window.addEventListener('beforeunload', window.appCleanupListener);
				
			} catch (error) {
				console.error('âŒ Critical initialization error:', error);
				
				// Fallback UI cu opÈ›iuni de recovery
				document.body.innerHTML = `
					<div style="
						display: flex;
						flex-direction: column;
						align-items: center;
						justify-content: center;
						min-height: 100vh;
						padding: 2rem;
						text-align: center;
						font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
						background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
					">
						<div style="
							background: white;
							padding: 2.5rem;
							border-radius: 16px;
							box-shadow: 0 20px 60px rgba(0,0,0,0.3);
							max-width: 540px;
							width: 100%;
						">
							<div style="
								width: 80px;
								height: 80px;
								margin: 0 auto 1.5rem;
								background: #fee;
								border-radius: 50%;
								display: flex;
								align-items: center;
								justify-content: center;
								font-size: 3rem;
							">âŒ</div>
							
							<h1 style="
								color: #dc2626;
								margin: 0 0 1rem 0;
								font-size: 1.75rem;
								font-weight: 700;
							">Failed to Initialize</h1>
							
							<p style="
								color: #4b5563;
								margin: 0 0 1.5rem 0;
								font-size: 1rem;
								line-height: 1.6;
							">
								The Template Manager could not start due to an error:
							</p>
							
							<pre style="
								background: #fef2f2;
								color: #dc2626;
								padding: 1rem;
								border-radius: 8px;
								text-align: left;
								overflow-x: auto;
								font-size: 0.875rem;
								line-height: 1.5;
								border: 1px solid #fecaca;
								margin: 0 0 1.5rem 0;
							">${escapeHtml(error.message || 'Unknown error')}</pre>
							
							<div style="
								display: flex;
								gap: 0.75rem;
								flex-direction: column;
							">
								<button 
									onclick="location.reload()" 
									style="
										background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
										color: white;
										border: none;
										padding: 0.875rem 1.5rem;
										border-radius: 8px;
										font-size: 1rem;
										font-weight: 600;
										cursor: pointer;
										transition: transform 0.2s;
									"
									onmouseover="this.style.transform='translateY(-2px)'"
									onmouseout="this.style.transform='translateY(0)'"
								>
									ğŸ”„ Reload Page
								</button>
								
								<button 
									onclick="localStorage.clear(); location.reload();" 
									style="
										background: #dc2626;
										color: white;
										border: none;
										padding: 0.875rem 1.5rem;
										border-radius: 8px;
										font-size: 1rem;
										font-weight: 600;
										cursor: pointer;
										transition: transform 0.2s;
									"
									onmouseover="this.style.transform='translateY(-2px)'"
									onmouseout="this.style.transform='translateY(0)'"
								>
									ğŸ—‘ï¸ Clear Storage & Reload
								</button>
								
								<details style="
									margin-top: 1rem;
									text-align: left;
								">
									<summary style="
										cursor: pointer;
										color: #6b7280;
										font-size: 0.875rem;
										user-select: none;
									">Show technical details</summary>
									<pre style="
										margin-top: 0.5rem;
										padding: 0.75rem;
										background: #f9fafb;
										border-radius: 4px;
										font-size: 0.75rem;
										color: #374151;
										overflow-x: auto;
									">${Utils.escapeHtml(error.stack || 'No stack trace available')}</pre>
								</details>
							</div>
						</div>
					</div>
				`;
			}
		}
/*
	ğŸ” Scroll to Top Button
	â†’ Buton cu sÄƒgeatÄƒ â†‘ care te duce instant la Ã®nceput cÃ¢nd scrollezi mult Ã®n jos
	
	ğŸš€ Virtual Scrolling
	â†’ RendereazÄƒ doar 12 cards vizibile (nu toate 1000) = scrolling super rapid fÄƒrÄƒ lag
	
	ğŸ‘ï¸ Click to View
	â†’ Click pe textul trunchiat "..." â†’ vezi tot textul Ã®ntr-un popup
*/
    </script>
</body>
</html>
